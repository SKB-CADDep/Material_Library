import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import json
import os
import subprocess
import uuid
import copy
import sys
from datetime import datetime
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.patches import Ellipse


# ======================================================================================
# БЛОК 1: КОНФИГУРАЦИЯ И КОНСТАНТЫ
# ======================================================================================

class Schema:
    """Константы для ключей JSON структуры материала."""
    METADATA = "metadata"
    PHYSICAL = "physical_properties"
    MECHANICAL = "mechanical_properties"
    CHEMICAL = "chemical_properties"

    # Вложенные ключи
    STRENGTH_CAT = "strength_category"
    COMPOSITION = "composition"
    TEMP_PAIRS = "temperature_value_pairs"
    APP_AREA = "application_area"
    NAME_STD = "name_material_standard"
    NAME_ALT = "name_material_alternative"

    # Поля значений
    REF_ID = "source_ref_id"
    VAL_STR_CAT = "value_strength_category"


# Константа для логов
LOG_FILENAME = "material_changelog.txt"

# Маппинги свойств
PHYSICAL_PROPERTIES_MAP = {
    "modulus_elasticity": {
        "name": "Модуль упругости",
        "symbol": "E",
        "unit": "МПа",
        "unit_type": "Модуль упругости"
    },
    "coefficient_linear_expansion": {
        "name": "Коэффициент линейного расширения (·10¯⁶)",
        "symbol": "α",
        "unit": "1/С",
        "unit_type": "Коэфф. лин. расширения"
    },
    "coefficient_thermal_conductivity": {
        "name": "Коэффициент теплопроводности",
        "symbol": "λ",
        "unit": "Вт/(м*С)",
        "unit_type": "Теплопроводность"
    },
    "density": {
        "name": "Плотность",
        "symbol": "ρ",
        "unit": "кг/м3",
        "unit_type": "Плотность"
    },
    "specific_heat": {
        "name": "Удельная теплоемкость",
        "symbol": "С",
        "unit": "Дж/(кг*С)",
        "unit_type": "Удельная теплоемкость"
    },
}

MECHANICAL_PROPERTIES_MAP = {
    "yield_strength": {
        "name": "Предел текучести",
        "symbol": "σ_0,2",
        "unit": "МПа",
        "unit_type": "Предел текучести"
    },
    "tensile_strength": {
        "name": "Предел прочности",
        "symbol": "σ_в",
        "unit": "МПа",
        "unit_type": "Предел прочности"
    },
    "impact_strength": {
        "name": "Ударная вязкость",
        "symbol": "KCU",
        "unit": "Дж/см2",
        "unit_type": "Ударная вязкость"
    },
    "tensile_strength_limit_10_thousands_hours": {
        "name": "Предел длит. прочности за 10 тыс.ч",
        "symbol": "σ_дп_10",
        "unit": "МПа",
        "unit_type": "Предел длит. прочности"
    },
    "tensile_strength_limit_100_thousands_hours": {
        "name": "Предел длит. прочности за 100 тыс.ч",
        "symbol": "σ_дп_100",
        "unit": "МПа",
        "unit_type": "Предел длит. прочности"
    },
    "tensile_strength_limit_200_thousands_hours": {
        "name": "Предел длит. прочности за 200 тыс.ч",
        "symbol": "σ_дп_200",
        "unit": "МПа",
        "unit_type": "Предел длит. прочности"
    },
    "tensile_strength_limit_250_thousands_hours": {
        "name": "Предел длит. прочности за 250 тыс.ч",
        "symbol": "σ_дп_250",
        "unit": "МПа",
        "unit_type": "Предел длит. прочности"
    },
    "сreep_strain_rate_1_100_thousands_hours": {
        "name": "Ползучесть при скорости деформации 1%/100 тыс.ч",
        "symbol": "σ_1_100",
        "unit": "МПа",
        "unit_type": "Ползучесть"
    },
    "decrement_oscillations_at_800": {
        "name": "Декремент колебаний при 800 (·10¯⁴)",
        "symbol": "δψ_800",
        "unit": "кгс/см2",
        "unit_type": "Декремент колебаний"
    },
    "decrement_oscillations_at_1200": {
        "name": "Декремент колебаний при 1200 (·10¯⁴)",
        "symbol": "δψ_1200",
        "unit": "кгс/см2",
        "unit_type": "Декремент колебаний"
    },
    "decrement_oscillations_at_1600": {
        "name": "Декремент колебаний при 1600 (·10¯⁴)",
        "symbol": "δψ_1600",
        "unit": "кгс/см2",
        "unit_type": "Декремент колебаний"
    },
    "fatigue_limit_for_smooth_specimen": {
        "name": "Предел выносливости (гладкий образец, N=10e7)",
        "symbol": "σ_-1_smooth",
        "unit": "МПа",
        "unit_type": "Предел выносливости"
    },
    "fatigue_limit_for_notched_specimen": {
        "name": "Предел выносливости (образец с надрезом, N=10e7)",
        "symbol": "σ_-1_notched",
        "unit": "МПа",
        "unit_type": "Предел выносливости"
    },
}

ALL_PROPERTIES_MAP = {**PHYSICAL_PROPERTIES_MAP, **MECHANICAL_PROPERTIES_MAP}

# Константа для сравнения списков (для логов)
LIST_ITEM_KEYS = {
    (Schema.MECHANICAL, Schema.STRENGTH_CAT): Schema.VAL_STR_CAT,
    (Schema.CHEMICAL, Schema.COMPOSITION): "composition_source",
    (Schema.CHEMICAL, Schema.COMPOSITION, "other_elements"): "element"
}

# Текстовые константы (сокращены для примера, используйте свои полные версии)
APP_TEXT = """Приложение "Material_Lib"
Версия: 2.02
Год: 2025.11.11
Промт-инженер: Гаврилов П.Я.
Тестировщики: Лалаева С.Г., Гаврилова Н.Я.
AI ассистент (кодогенерирующий): gemini-2.5-pro

Приложение для управления и анализа
свойств конструкционных материалов.
"""
INSTR_TEXT = """1. НАЧАЛО РАБОТЫ

1.1. Для начала работы выберите меню "Файл" -> "Открыть директорию..." и укажите папку, в которой находятся ваши JSON-файлы материалов.
1.2. Если рядом с приложением есть папка "БД Материалов", она будет загружена автоматически при старте.
1.3. Области применения собираются автоматически из загруженных файлов (metadata.application_area). Для добавления новых областей используйте вкладку "Добавление / Редактирование материала" -> "Общие данные".
1.4. После загрузки материалов вкладки приложения станут активны.

2. ВКЛАДКА "ПОДБОР МАТЕРИАЛА"

Эта вкладка предназначена для анализа существующих материалов (без изменения файлов).

2.1. Подбор по температуре:
   - Отфильтруйте материалы по "Область применения" (необязательно).
   - Выберите тип свойств: "Физические свойства", "Механические свойства" или "Твердость".
   - Введите температуру (°С) — расчёт выполняется автоматически (интерполяция между ближайшими точками).
   - В таблице показываются материалы, категория прочности (КП), источники (НТД) и значения свойств при выбранной температуре.
   - Сортировка: щёлкните по заголовку столбца. Копирование: ПКМ по ячейке -> "Копировать".

2.2. Расчёт отдельно:
   - Фильтруйте по "Область применения" (необязательно), затем выберите материал и (при наличии) его категорию прочности.
   - Введите температуру и нажмите "Рассчитать".
   - Будут показаны значения всех ключевых свойств при заданной температуре.
   - Переключение единиц доступно для свойств, где предусмотрена конвертация (например, МПа ⇄ кгс/см²). Кнопка "Сбросить" возвращает значения и единицы по умолчанию.

2.3. Сравнение материалов (свойства):
   - Выберите свойство из выпадающего списка.
   - Найдите материалы через поле "Поиск" и добавьте их в список "Выбранные" двойным кликом. Удаление — тоже двойной клик по выбранному.
   - Нажмите "Построить график". Строится зависимость выбранного свойства от температуры для каждого материала/категории.
   - Подписи точек отображают значения. Кнопка "Домой" сбрасывает вид (перерисовка), Zoom/панорамирование доступны на панели.
   - Ограничение цвета: одновременно различимо до 10 кривых.

2.4. Сравнение материалов (хим. состав):
   - Отфильтруйте материалы по "Область применения" и/или используйте поиск.
   - Выделите один или несколько материалов (список слева). При выборе конкретной области (и пустом поиске) все материалы выделяются автоматически.
   - В таблице показывается химический состав по источникам. Над таблицей — поля фильтров по элементам (%).
   - Ввод целевого значения по элементу подсвечивает строки:
     * Зеленым — совпадение по всем заданным фильтрам;
     * Розовым — есть несовпадение.
   - Подсказки по влиянию элементов доступны при наведении на заголовок столбца с символом элемента.

2.5. Диаграмма Эшби:
   - Выберите свойства для осей X и Y.
   - Через поиск добавьте материалы в список "Выбранные" (двойной клик), удаление — двойной клик по выбранному.
   - На диаграмме каждый материал отображается эллипсом, охватывающим диапазон значений (min..max) по каждой оси.
   - По умолчанию: X — "Предел текучести (σ_0,2)", Y — "Температура (T)". Панель инструментов поддерживает масштабирование и панорамирование.

3. ВКЛАДКА "ДОБАВЛЕНИЕ / РЕДАКТИРОВАНИЕ МАТЕРИАЛА"

Все изменения выполняются во временной копии и не попадают в файл до сохранения.

3.1. Верхняя панель:
   - Выбор материала из выпадающего списка.
   - Кнопки: "Сохранить", "Сохранить как...", "Отменить изменения".
     • "Сохранить" — перезаписывает исходный файл (если он есть).
     • "Сохранить как..." — сохраняет под новым именем/в новую папку и перезагружает базу из выбранной директории.
     • "Отменить изменения" — откатывает несохранённые правки текущего материала.

3.2. Общие данные:
   - Наименование (стандарт), альтернативные названия, общий комментарий.
   - Классификация: категория, класс, подкласс.
   - Области применения: список чекбоксов + поле "Добавить область применения".
   - Параметры применения: "Температура применения ДО, °С" и комментарий.

3.3. Физические свойства:
   - Для каждого свойства указываются источник, под-источник, комментарий и таблица точек (температура — значение).
   - Редактирование ячейки — двойной клик; "+" добавляет строку; "-" удаляет выбранную строку.
   - График справа обновляется по мере изменения таблицы.
   - Числовые значения вводите с точкой (например, 20.5).

3.4. Механические свойства:
   - Свойства задаются по категориям прочности (КП). Добавляйте/удаляйте категории кнопками "+" / "-".
   - Внутри каждой категории свойства редактируются аналогично физическим (источник, таблица точек, график).
   - Блок "Твердость" редактируется отдельной таблицей (источник, под-источник, min/max, ед. изм.).

3.5. Химический состав:
   - Источники состава: добавление/удаление источников и их редактирование.
   - Таблица элементов: элемент, min/max (%), единица (по умолчанию "%"), допуски min/max (строки).
   - Строки без названия элемента игнорируются при сохранении.

3.6. Сохранение и логирование:
   - При сохранении вычисляются и записываются изменения в файл "material_changelog.txt" (рядом с приложением).
   - В журнал попадает: время, пользователь, материал и список изменённых полей.

4. ВКЛАДКА "РАБОТА С ИСТОЧНИКАМИ"

4.1. Просмотр:
   - Автоматически собираются все уникальные источники и под-источники из физических/механических свойств, твердости и хим. состава.
   - Если в папке "Источники" (рядом с приложением) найден файл с таким именем (или тем же именем и популярным расширением: .pdf, .docx, .xlsx, .txt, .jpg, .png), в таблице появляется кликабельная ссылка.
   - Клик по ссылке открывает файл системным приложением.

5. ВАЖНЫЕ ЗАМЕЧАНИЯ

5.1. Структура JSON: Приложение ожидает корректную структуру (metadata, physical_properties, mechanical_properties.strength_category, chemical_properties.composition). Нарушение структуры может вызвать ошибки.
5.2. Числовые значения: Вводите числа через точку (например, 123.45). Запись с запятой (",") будет проигнорирована.
5.3. Горячие клавиши: Копирование/вставка/вырезание/выделение работают только на английской раскладке.
5.4. Папки рядом с приложением: "БД Материалов" (для автозагрузки базы при старте — по желанию) и "Источники" (для открытия связанных файлов) можно держать рядом с .exe.
"""
CHANGELOG_TEXT = """
"""

# ======================================================================================
# БЛОК 2: УТИЛИТЫ
# ======================================================================================

class MathUtils:
    """Утилиты для математических расчетов."""

    @staticmethod
    def safe_float(value, default=None):
        """Безопасное преобразование строки в float."""
        if value is None: return default
        if isinstance(value, (float, int)): return float(value)
        try:
            return float(str(value).strip().replace(',', '.'))
        except (ValueError, TypeError):
            return default

    @staticmethod
    def linear_interpolate(pairs, target_x):
        """
        Линейная интерполяция значения Y для target_x по списку пар [(x, y), ...].
        Не выполняет экстраполяцию (возвращает None).
        """
        if not pairs: return None

        # Сортировка пар по X
        sorted_pairs = sorted(pairs, key=lambda p: p[0])

        # Проверка границ
        if target_x < sorted_pairs[0][0] or target_x > sorted_pairs[-1][0]:
            return None  # Экстраполяция запрещена или невозможна

        # Точное совпадение
        for x, y in sorted_pairs:
            if x == target_x: return y

        # Поиск интервала
        for i in range(len(sorted_pairs) - 1):
            x1, y1 = sorted_pairs[i]
            x2, y2 = sorted_pairs[i + 1]
            if x1 < target_x < x2:
                if x2 - x1 == 0: return y1
                return y1 + (target_x - x1) * (y2 - y1) / (x2 - x1)

        return None


def get_app_directory():
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(os.path.abspath(__file__))


def get_username():
    try:
        return os.getlogin()
    except Exception:
        return os.environ.get("USERNAME", "unknown_user")


def read_text_from_file(filename):
    embedded = {"app_list.txt": APP_TEXT, "instruction_list.txt": INSTR_TEXT, "change_list.txt": CHANGELOG_TEXT}
    return embedded.get(filename, f"ОШИБКА: Не удалось прочитать '{filename}'")


def find_changes(old_data, new_data):
    """
    Главная функция для поиска изменений. Подготавливает данные и вызывает рекурсивный хелпер.
    Возвращает структурированный список изменений.
    """

    def find_changes_recursive(d1, d2, path):
        changes = []
        if isinstance(d1, dict) and isinstance(d2, dict):
            all_keys = sorted(list(set(d1.keys()) | set(d2.keys())))
            for key in all_keys:
                if key in ["material_id", "property_last_updated"]: continue
                new_path = path + [key]
                val1, val2 = d1.get(key), d2.get(key)
                if val1 is None and val2 is not None:
                    changes.append({'path': new_path, 'type': 'added', 'new': val2})
                elif val1 is not None and val2 is None:
                    changes.append({'path': new_path, 'type': 'removed', 'old': val1})
                elif val1 != val2:
                    changes.extend(find_changes_recursive(val1, val2, new_path))
        elif isinstance(d1, list) and isinstance(d2, list):
            unique_key_name = LIST_ITEM_KEYS.get(tuple(path))
            is_list_of_dicts_with_key = (unique_key_name and
                                         all(isinstance(item, dict) and unique_key_name in item for item in d1 + d2))
            if is_list_of_dicts_with_key:
                old_map = {item[unique_key_name]: item for item in d1}
                new_map = {item[unique_key_name]: item for item in d2}
                all_item_keys = sorted(list(set(old_map.keys()) | set(new_map.keys())))
                for item_key in all_item_keys:
                    old_item = old_map.get(item_key)
                    new_item = new_map.get(item_key)
                    item_path = path + [f"{path[-1]}[{item_key}]"]
                    if old_item is None:
                        changes.append({'path': item_path, 'type': 'added', 'new': new_item})
                    elif new_item is None:
                        changes.append({'path': item_path, 'type': 'removed', 'old': old_item})
                    elif old_item != new_item:
                        changes.extend(find_changes_recursive(old_item, new_item, item_path))
            else:
                if json.dumps(d1, sort_keys=True) != json.dumps(d2, sort_keys=True):
                    changes.append({'path': path, 'type': 'modified', 'old': d1, 'new': d2})
        elif d1 != d2:
            changes.append({'path': path, 'type': 'modified', 'old': d1, 'new': d2})
        return changes

    return find_changes_recursive(copy.deepcopy(old_data), copy.deepcopy(new_data), [])


def log_changes(material_name, changes_list):
    """Записывает изменения в лог-файл в иерархическом виде."""
    if not changes_list: return
    log_path = os.path.join(get_app_directory(), LOG_FILENAME)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    username = get_username()
    try:
        with open(log_path, 'a', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write(f"Время: {timestamp}\n")
            f.write(f"Пользователь: {username}\n")
            f.write(f"Материал: {material_name}\n")
            f.write("Изменения:\n")
            printed_headers = set()
            for change in changes_list:
                path = change['path']
                for i in range(len(path) - 1):
                    header_path_tuple = tuple(path[:i + 1])
                    if header_path_tuple not in printed_headers:
                        indent = "  " * (i + 1)
                        header_name = path[i]
                        if isinstance(header_name, int): f.write(f"{indent}Изменения в элементе с индексом [{header_name}]:\n")
                        else: f.write(f"{indent}Изменения в '{header_name}':\n")
                        printed_headers.add(header_path_tuple)
                leaf_key = path[-1]
                indent = "  " * len(path)
                ct = change['type']
                if ct == 'modified': f.write(f"{indent}- '{leaf_key}': [БЫЛО] '{change['old']}' -> [СТАЛО] '{change['new']}'\n")
                elif ct == 'added': f.write(f"{indent}- '{leaf_key}': [ДОБАВЛЕНО] -> '{change['new']}'\n")
                elif ct == 'removed': f.write(f"{indent}- '{leaf_key}': [УДАЛЕНО] (было '{change['old']}')\n")
            f.write("\n")
    except Exception as e:
        print(f"Ошибка записи в лог-файл: {e}")


def safe_float(value, default=None):
    """
    Безопасное преобразование строки в float.
    Меняет запятую на точку. Возвращает default при ошибке.
    """
    if value is None: return default
    if isinstance(value, (float, int)): return float(value)
    try:
        # Убираем пробелы и меняем запятую на точку
        return float(str(value).strip().replace(',', '.'))
    except (ValueError, TypeError):
        return default


class ScrollableMixin:
    """Миксин для прокрутки колесом мыши."""
    def bind_mouse_wheel(self, widget, target_widget=None):
        target = target_widget if target_widget else widget
        def _on_mousewheel(event):
            if isinstance(event.widget, ttk.Combobox): pass
            if hasattr(event, 'delta') and event.delta != 0:
                target.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif hasattr(event, 'num'):
                if event.num == 4: target.yview_scroll(-1, "units")
                elif event.num == 5: target.yview_scroll(1, "units")
            return "break"
        widget.bind("<MouseWheel>", _on_mousewheel)
        widget.bind("<Button-4>", _on_mousewheel)
        widget.bind("<Button-5>", _on_mousewheel)

    def bind_all_children(self, parent_widget, target_canvas):
        self.bind_mouse_wheel(parent_widget, target_canvas)
        for child in parent_widget.winfo_children():
            self.bind_all_children(child, target_canvas)


# ======================================================================================
# БЛОК 3: БИЗНЕС-ЛОГИКА (CORE)
# ======================================================================================


class UnitManager:
    """
    Менеджер единиц измерения.
    Архитектура:
    1. У каждого типа есть одна SYSTEM_UNIT (Закон проекта).
    2. factors хранит коэффициент перевода: ИЗ Единицы -> В System_Unit.
       Пример: Pressure System = кгс/см2.
       Factor для МПа = 10.197162 (т.е. 1 МПа * 10.197 = Значение в кгс/см2).
    """

    REGISTRY = {
        "Давление": {
            "system_unit": "кгс/см2",
            "factors": {
                "кгс/см2": 1.0,
                "МПа": 10.197162,
                "бар": 1.019716,
                "Па": 1.019716e-5,
                "кПа": 0.010197,
                "мм рт.ст.": 0.0013595,
                "мм вод.ст.": 0.0001,
                "атм": 1.033227,
                "psi": 0.070307,
                "ksi": 70.3069
            }
        },
        "Температура": {
            "system_unit": "C",
            "factors": {
                "C": 1.0,
                "K": "offset_k",  # Спец. обработка
                "F": "offset_f"   # Спец. обработка
            }
        },
        "Расход": {
            "system_unit": "т/ч",
            "factors": {
                "т/ч": 1.0,
                "кг/с": 3.6,
                "кг/ч": 0.001,
                "т/с": 3600.0
            }
        },
        "Объемный расход": {
            "system_unit": "м3/ч",
            "factors": {
                "м3/ч": 1.0,
                "м3/с": 3600.0,
                "л/с": 3.6,
                "л/мин": 0.06,
                "л/ч": 0.001
            }
        },
        "Скорость": {
            "system_unit": "м/с",
            "factors": {
                "м/с": 1.0,
                "км/ч": 0.277778,
                "узлы": 0.514444
            }
        },
        "Плотность": {
            "system_unit": "кг/м3",
            "factors": {
                "кг/м3": 1.0,
                "г/см3": 1000.0,
                "т/м3": 1000.0
            }
        },
        "Удельный объем": {
            "system_unit": "м3/кг",
            "factors": {
                "м3/кг": 1.0,
                "см3/г": 0.001,
                "л/кг": 0.001,
                "ft3/lb": 0.062428
            }
        },
        "Вязкость дин.": {
            "system_unit": "кг/(м*с)",
            "factors": {
                "кг/(м*с)": 1.0,
                "Па*с": 1.0,
                "Пуаз": 0.1,
                "сП": 0.001
            }
        },
        "Вязкость кин.": {
            "system_unit": "м2/с",
            "factors": {
                "м2/с": 1.0,
                "сСт": 1e-6,
                "Ст": 1e-4
            }
        },
        "Энтальпия": {
            "system_unit": "ккал/кг",
            "factors": {
                "ккал/кг": 1.0,
                "кал/кг": 0.001,
                "кДж/кг": 0.238846,
                "Дж/кг": 0.0002388
            }
        },
        "Энтропия": {
            "system_unit": "ккал/(кг*С)",
            "factors": {
                "ккал/(кг*С)": 1.0,
                "кал/(кг*С)": 0.001,
                "кДж/(кг*К)": 0.238846,
                "кДж/(кг*С)": 0.238846,
                "Дж/(кг*К)": 0.0002388
            }
        },
        "Степень сухости": {
            "system_unit": "-",
            "factors": {
                "-": 1.0,
                "%": 0.01
            }
        },
        "Удельная теплоемкость": {
            "system_unit": "ккал/(кг*С)",
            "factors": {
                "ккал/(кг*С)": 1.0,
                "кДж/(кг*К)": 0.238846,
                "кДж/(кг*С)": 0.238846,
                "Дж/(кг*К)": 0.0002388,
                "Дж/(кг*С)": 0.0002388
            }
        },
        "Теплопроводность": {
            "system_unit": "Вт/(м*К)",
            "factors": {
                "Вт/(м*К)": 1.0,
                "ккал/(ч*м*С)": 1.163
            }
        },
        "Мощность": {
            "system_unit": "МВт",
            "factors": {
                "МВт": 1.0,
                "кВт": 0.001,
                "Вт": 1e-6,
                "ГВт": 1000.0,
                "Гкал/ч": 1.163,
                "ккал/ч": 1.163e-6,
                "л.с.": 7.35499e-4
            }
        },
        "Энергия": {
            "system_unit": "Гкал",
            "factors": {
                "Гкал": 1.0,
                "ккал": 1e-6,
                "МВт*ч": 0.859845,
                "кВт*ч": 0.0008598,
                "ГДж": 0.238846,
                "кДж": 2.388e-7
            }
        },
        "Сила": {
            "system_unit": "Н",
            "factors": {
                "Н": 1.0,
                "кН": 1000.0,
                "кгс": 9.80665,
                "lbf": 4.44822,
                "дина": 1e-5
            }
        },
        "Момент силы": {
            "system_unit": "Н*м",
            "factors": {
                "Н*м": 1.0,
                "кгс*м": 9.80665,
                "кН*м": 1000.0
            }
        },
        "Частота": {
            "system_unit": "Гц",
            "factors": {
                "Гц": 1.0,
                "кГц": 1000.0,
                "МГц": 1000000.0,
                "об/с": 1.0,
                "об/мин": 0.0166667
            }
        },
        "Теплоотдача": {
            "system_unit": "Вт/(м2*К)",
            "factors": {
                "Вт/(м2*К)": 1.0,
                "Вт/(м2*С)": 1.0
            }
        },
        "Длина": {
            "system_unit": "мм",
            "factors": {
                "км": 1000000,
                "м": 1000,
                "дм": 100,
                "см": 10,
                "мм": 1,
                "мкм": 0.001,
                "микрон": 0.001,
                "св.лет": 9460000000000000000.00,
                "вершки": 44.45,
                "пяди": 177.8,
                "аршины": 711.2,
                "сажени": 2133.6,
                "версты": 1066800,
                "дюймы": 25.4,
                "футы": 304.8,
                "ярды": 914.4,
                "мили": 1609344,
                "лье": 5556000
            }
        },
        "Площадь": {
            "system_unit": "м2",
            "factors": {
                "см2": 0.0001,
                "м2": 1,
                "сотки": 100,
                "Га": 10000,
                "акры": 4046.86
            }
        },
        "Объем": {
            "system_unit": "м3",
            "factors": {
                "м3": 1.0,
                "л": 0.001,
                "мл": 1e-6,
                "см3": 1e-6,
                "баррель": 0.158987,
                "галлон (US)": 0.00378541,
                "фут3": 0.0283168
            }
        },
        "Масса": {
            "system_unit": "кг",
            "factors": {
                "тонны": 1000,
                "центнер": 100,
                "кг": 1,
                "грамм": 0.001,
                "унции": 0.02835,
                "lb": 0.453592
            }
        },
        "Время": {
            "system_unit": "с",
            "factors": {
                "с": 1.0,
                "мин": 60.0,
                "ч": 3600.0,
                "сутки": 86400.0,
                "год": 31536000.0
            }
        },
        "Угол": {
            "system_unit": "град",
            "factors": {
                "град": 1,
                "радианы": 57.3
            }
        },
        "Безразмерный": {
            "system_unit": "-",
            "factors": {
                "-": 1.0,
                "%": 0.01
            }
        },
        "Твердость": {
            "system_unit": "HB",
            "factors": {
                "HB": 1.0,
                "HRA": "table",
                "HRC": "table",
                "HRB": "table",
                "HV": "table",
                "HSD": "table"
            }
        },
        "Декремент колебаний": {
            "system_unit": "-",
            "factors": {
                "-": 1.0,
                "%": 0.01,
                "Np": 1.0,
                "dB": 0.1151
            }
        },
        "Ползучесть": {
            "system_unit": "%",
            "factors": {
                "%": 1.0,
                "-": 100.0,
                "mm/mm": 100.0,
                "m/m": 100.0
            }
        },
        "Предел прочности": {
            "system_unit": "МПа",
            "factors": {
                "МПа": 1.0,
                "Па": 1e-6,
                "кПа": 0.001,
                "ГПа": 1000.0,
                "кгс/мм2": 9.80665,
                "кгс/см2": 0.0980665,
                "бар": 0.1,
                "psi": 0.00689476,
                "ksi": 6.89476,
                "N/mm2": 1.0
            }
        },
        "Предел длит. прочности": {
            "system_unit": "МПа",
            "factors": {
                "МПа": 1.0,
                "Па": 1e-6,
                "кПа": 0.001,
                "ГПа": 1000.0,
                "кгс/мм2": 9.80665,
                "кгс/см2": 0.0980665,
                "бар": 0.1,
                "psi": 0.00689476,
                "ksi": 6.89476,
                "N/mm2": 1.0,
                "tsf": 0.09576,
                "тс/м2": 0.00980665
            }
        },
        "Предел текучести": {
            "system_unit": "МПа",
            "factors": {
                "МПа": 1.0,
                "Па": 1e-6,
                "кПа": 0.001,
                "ГПа": 1000.0,
                "кгс/мм2": 9.80665,
                "кгс/см2": 0.0980665,
                "бар": 0.1,
                "psi": 0.00689476,
                "ksi": 6.89476,
                "N/mm2": 1.0
            }
        },
        "Предел выносливости": {
            "system_unit": "МПа",
            "factors": {
                "МПа": 1.0,
                "Па": 1e-6,
                "кПа": 0.001,
                "ГПа": 1000.0,
                "кгс/мм2": 9.80665,
                "кгс/см2": 0.0980665,
                "бар": 0.1,
                "psi": 0.00689476,
                "ksi": 6.89476,
                "N/mm2": 1.0
            }
        },
        "Модуль упругости": {
            "system_unit": "МПа",
            "factors": {
                "МПа": 1.0,
                "ГПа": 1000.0,
                "Па": 1e-6,
                "кгс/мм2": 9.80665,
                "кгс/см2": 0.0980665,
                "psi": 0.00689476,
                "ksi": 6.89476,
                "Mpsi": 6894.76,
                "N/mm2": 1.0
            }
        },
        "Ударная вязкость": {
            "system_unit": "кДж/м2",
            "factors": {
                "кДж/м2": 1.0,
                "Дж/м2": 0.001,
                "Дж/см2": 10.0,
                "кгс*м/см2": 98.0665,
                "кгс*м/м2": 0.00980665,
                "ft*lbf/in2": 2.1015
            }
        },
        "Коэфф. лин. расширения": {
            "system_unit": "1/С",
            "factors": {
                "1/С": 1.0,
                "1/K": 1.0,
                "1/F": 1.8,
                "мк/С": 1e-6,
                "10^-6/C": 1e-6,
                "10^-6/K": 1e-6,
                "10^-6/F": 1.8e-6
            }
        }
    }

    # Маппинг для библиотеки seuif97:
    # Какой тип данных ожидает библиотека и в какой единице (SI).
    # Это нужно для конвертации: System -> SI (для библиотеки).
    LIB_SI_TARGETS = {
        "Давление": "МПа",
        "Температура": "C",        # В seuif97 T в градусах Цельсия (или Кельвинах, но C удобнее)
        "Энтальпия": "кДж/кг",
        "Энтропия": "кДж/(кг*К)",
        "Удельный объем": "м3/кг",
        "Степень сухости": "-",
        "Плотность": "кг/м3",
        "Вязкость дин.": "Па*с",
        "Вязкость кин.": "м2/с",
        "Теплопроводность": "Вт/(м*К)",
        "Безразмерный": "-",
        "КПД": "-",                 # ief возвращает доли
    }

    # ==========================================
    # ТАБЛИЦА ПЕРЕВОДА ТВЕРДОСТИ
    # Сортировка: по возрастанию d10 (диаметр отпечатка)
    # Формат кортежа: (d10, HB, HRA, HRC, HRB, HV, HSD)
    # Если значения нет, стоит None.
    # ==========================================
    HARDNESS_DATA = [
        (2.3, 712, 85.1, 66.4, None, 1016, 98.3),
        (2.31, 706, 84.9, 66.0, None, 999, 97.8),
        (2.32, 700, 84.7, 65.7, None, 983, 97.4),
        (2.33, 694, 84.5, 65.3, None, 967, 96.9),
        (2.34, 688, 84.3, 65.0, None, 951, 96.3),
        (2.35, 682, 84.1, 64.6, None, 936, 95.8),
        (2.36, 676, 83.9, 64.3, None, 922, 95.3),
        (2.37, 670, 83.6, 63.9, None, 907, 94.7),
        (2.38, 665, 83.4, 63.6, None, 893, 94.1),
        (2.39, 659, 83.2, 63.2, None, 880, 93.5),
        (2.4, 653, 83.0, 62.9, None, 866, 92.9),
        (2.41, 648, 82.8, 62.5, None, 853, 92.3),
        (2.42, 643, 82.6, 62.1, None, 841, 91.7),
        (2.43, 637, 82.4, 61.8, None, 828, 91.1),
        (2.44, 632, 82.2, 61.4, None, 816, 90.4),
        (2.45, 627, 82.0, 61.1, None, 804, 89.8),
        (2.46, 621, 81.8, 60.7, None, 793, 89.1),
        (2.47, 616, 81.6, 60.4, None, 782, 88.5),
        (2.48, 611, 81.4, 60.0, None, 771, 87.8),
        (2.49, 606, 81.3, 59.7, None, 760, 87.2),
        (2.5, 601, 81.1, 59.3, None, 750, 86.5),
        (2.51, 597, 80.9, 59.0, None, 739, 85.9),
        (2.52, 592, 80.7, 58.6, None, 730, 85.2),
        (2.53, 587, 80.5, 58.3, None, 720, 84.5),
        (2.54, 582, 80.3, 57.9, None, 710, 83.9),
        (2.55, 578, 80.1, 57.6, None, 701, 83.2),
        (2.56, 573, 79.9, 57.2, None, 692, 82.6),
        (2.57, 569, 79.7, 56.9, None, 683, 81.9),
        (2.58, 564, 79.6, 56.5, None, 675, 81.3),
        (2.59, 560, 79.4, 56.2, None, 666, 80.6),
        (2.6, 555, 79.2, 55.8, None, 658, 80.0),
        (2.61, 551, 79.0, 55.5, None, 650, 79.3),
        (2.62, 547, 78.8, 55.1, None, 643, 78.7),
        (2.63, 542, 78.6, 54.8, None, 635, 78.0),
        (2.64, 538, 78.5, 54.5, None, 627, 77.4),
        (2.65, 534, 78.3, 54.1, None, 620, 76.8),
        (2.66, 530, 78.1, 53.8, None, 613, 76.2),
        (2.67, 526, 77.9, 53.5, None, 606, 75.6),
        (2.68, 522, 77.7, 53.1, None, 599, 74.9),
        (2.69, 518, 77.6, 52.8, None, 593, 74.3),
        (2.7, 514, 77.4, 52.5, None, 586, 73.7),
        (2.71, 510, 77.2, 52.2, None, 580, 73.2),
        (2.72, 506, 77.0, 51.8, None, 574, 72.6),
        (2.73, 503, 76.9, 51.5, None, 568, 72.0),
        (2.74, 499, 76.7, 51.2, None, 562, 71.4),
        (2.75, 495, 76.5, 50.9, None, 556, 70.9),
        (2.76, 492, 76.4, 50.6, None, 550, 70.3),
        (2.77, 488, 76.2, 50.3, None, 544, 69.8),
        (2.78, 484, 76.0, 50.0, None, 539, 69.2),
        (2.79, 481, 75.8, 49.7, None, 534, 68.7),
        (2.8, 477, 75.7, 49.4, None, 528, 68.1),
        (2.81, 474, 75.5, 49.1, None, 523, 67.6),
        (2.82, 470, 75.4, 48.8, None, 518, 67.1),
        (2.83, 467, 75.2, 48.5, None, 513, 66.6),
        (2.84, 464, 75.0, 48.2, None, 508, 66.1),
        (2.85, 460, 74.9, 47.9, None, 504, 65.6),
        (2.86, 457, 74.7, 47.6, None, 499, 65.1),
        (2.87, 454, 74.6, 47.3, None, 494, 64.6),
        (2.88, 451, 74.4, 47.0, None, 490, 64.1),
        (2.89, 447, 74.2, 46.8, None, 485, 63.7),
        (2.9, 444, 74.1, 46.5, None, 481, 63.2),
        (2.91, 441, 73.9, 46.2, None, 477, 62.7),
        (2.92, 438, 73.8, 45.9, None, 473, 62.3),
        (2.93, 435, 73.6, 45.7, None, 468, 61.8),
        (2.94, 432, 73.5, 45.4, None, 464, 61.4),
        (2.95, 429, 73.3, 45.1, None, 460, 61.0),
        (2.96, 426, 73.2, 44.9, None, 456, 60.5),
        (2.97, 423, 73.0, 44.6, None, 453, 60.1),
        (2.98, 420, 72.9, 44.4, None, 449, 59.7),
        (2.99, 417, 72.7, 44.1, None, 445, 59.3),
        (3.0, 415, 72.6, 43.8, None, 441, 58.9),
        (3.01, 412, 72.4, 43.6, None, 438, 58.5),
        (3.02, 409, 72.3, 43.3, None, 434, 58.1),
        (3.03, 406, 72.2, 43.1, None, 431, 57.7),
        (3.04, 403, 72.0, 42.9, None, 427, 57.3),
        (3.05, 401, 71.9, 42.6, None, 424, 56.9),
        (3.06, 398, 71.8, 42.4, None, 420, 56.5),
        (3.07, 395, 71.6, 42.1, None, 417, 56.2),
        (3.08, 393, 71.5, 41.9, None, 414, 56.8),
        (3.09, 390, 71.3, 41.7, None, 411, 55.4),
        (3.1, 388, 71.2, 41.4, None, 408, 55.1),
        (3.11, 385, 71.1, 41.2, None, 404, 54.7),
        (3.12, 383, 71.0, 40.9, None, 401, 54.4),
        (3.13, 380, 70.8, 40.7, None, 398, 54.0),
        (3.14, 378, 70.7, 40.5, None, 395, 53.7),
        (3.15, 375, 70.6, 40.3, None, 392, 53.3),
        (3.16, 373, 70.4, 40.0, None, 389, 53.0),
        (3.17, 370, 70.3, 39.8, None, 386, 52.7),
        (3.18, 368, 70.2, 39.6, None, 384, 52.3),
        (3.19, 366, 70.1, 39.3, None, 381, 52.0),
        (3.2, 363, 70.0, 39.1, None, 378, 51.7),
        (3.21, 361, 69.8, 38.9, None, 375, 51.4),
        (3.22, 359, 69.7, 38.7, None, 372, 51.1),
        (3.23, 356, 69.6, 38.5, None, 370, 50.8),
        (3.24, 354, 69.5, 38.2, None, 367, 50.4),
        (3.25, 352, 69.4, 38.0, None, 364, 50.1),
        (3.26, 350, 69.2, 37.8, None, 362, 49.8),
        (3.27, 347, 69.1, 37.6, None, 359, 49.5),
        (3.28, 345, 69.0, 37.4, None, 357, 49.2),
        (3.29, 343, 68.9, 37.1, None, 354, 48.9),
        (3.3, 341, 68.8, 36.9, None, 352, 48.6),
        (3.31, 339, 68.7, 36.7, None, 349, 48.4),
        (3.32, 337, 68.6, 36.5, None, 347, 48.1),
        (3.33, 335, 68.5, 36.3, None, 344, 47.8),
        (3.34, 333, 68.4, 36.0, None, 342, 47.5),
        (3.35, 331, 68.2, 35.8, None, 340, 47.2),
        (3.36, 329, 68.1, 35.6, None, 337, 46.9),
        (3.37, 327, 68.0, 35.4, None, 335, 46.6),
        (3.38, 325, 67.9, 35.2, None, 333, 46.4),
        (3.39, 323, 67.8, 34.9, None, 331, 46.1),
        (3.4, 321, 67.7, 34.7, None, 328, 45.8),
        (3.41, 319, 67.6, 34.5, None, 326, 45.5),
        (3.42, 317, 67.5, 34.3, None, 324, 45.3),
        (3.43, 315, 67.4, 34.1, None, 322, 45.0),
        (3.44, 313, 67.3, 33.8, None, 320, 44.7),
        (3.45, 311, 67.2, 33.6, None, 317, 44.5),
        (3.46, 309, 67.1, 33.4, None, 315, 44.2),
        (3.47, 307, 67.0, 33.2, None, 313, 44.0),
        (3.48, 306, 66.9, 33.0, None, 311, 43.7),
        (3.49, 304, 66.8, 32.7, None, 309, 43.4),
        (3.5, 302, 66.7, 32.5, None, 307, 43.2),
        (3.51, 300, 66.6, 32.3, None, 305, 42.9),
        (3.52, 298, 66.5, 32.1, None, 303, 42.7),
        (3.53, 297, 66.4, 31.9, None, 301, 42.4),
        (3.54, 295, 66.3, 31.6, None, 299, 42.2),
        (3.55, 293, 66.2, 31.4, None, 298, 41.9),
        (3.56, 292, 66.1, 31.2, None, 296, 41.7),
        (3.57, 290, 66.0, 31.0, None, 294, 41.4),
        (3.58, 288, 65.9, 30.8, None, 292, 41.2),
        (3.59, 287, 65.8, 30.5, None, 290, 40.9),
        (3.6, 285, 65.7, 30.3, None, 288, 40.7),
        (3.61, 283, 65.6, 30.1, None, 286, 40.5),
        (3.62, 282, 65.5, 29.9, None, 285, 40.2),
        (3.63, 280, 65.5, 29.7, None, 283, 40.0),
        (3.64, 278, 65.4, 29.4, None, 281, 39.7),
        (3.65, 277, 65.3, 29.2, None, 280, 39.5),
        (3.66, 275, 65.2, 29.0, None, 278, 39.3),
        (3.67, 274, 65.1, 28.8, None, 276, 39.1),
        (3.68, 272, 65.0, 28.6, None, 274, 38.8),
        (3.69, 271, 64.9, 28.3, None, 273, 38.6),
        (3.7, 269, 64.8, 28.1, None, 271, 38.4),
        (3.71, 268, 64.7, 27.9, None, 270, 38.1),
        (3.72, 266, 64.6, 27.7, None, 268, 37.9),
        (3.73, 265, 64.5, 27.5, None, 266, 37.7),
        (3.74, 263, 64.4, 27.3, None, 265, 37.5),
        (3.75, 262, 64.3, 27.1, None, 263, 37.3),
        (3.76, 260, 64.2, 26.8, None, 262, 37.1),
        (3.77, 259, 64.1, 26.6, None, 260, 36.8),
        (3.78, 257, 64.0, 26.4, None, 259, 36.6),
        (3.79, 256, 63.9, 26.2, None, 257, 36.4),
        (3.8, 255, 63.8, 26.0, None, 256, 36.2),
        (3.81, 253, 63.7, 25.8, None, 254, 36.0),
        (3.82, 252, 63.6, 25.6, None, 253, 35.8),
        (3.83, 251, 63.5, 25.4, None, 251, 35.6),
        (3.84, 249, 63.4, 25.2, None, 250, 35.4),
        (3.85, 248, 63.3, 25.0, None, 249, 35.2),
        (3.86, 246, 63.2, 24.8, None, 247, 35.0),
        (3.87, 245, 63.1, 24.6, None, 246, 34.8),
        (3.88, 244, 63.0, 24.4, 100.0, 244, 34.6),
        (3.89, 243, 62.9, 24.2, 99.9, 243, 34.4),
        (3.9, 241, 62.8, 24.0, 99.8, 242, 34.2),
        (3.91, 240, 62.7, 23.8, 99.6, 240, 34.1),
        (3.92, 239, 62.6, 23.6, 99.5, 239, 33.9),
        (3.93, 237, 62.5, 23.4, 99.3, 238, 33.7),
        (3.94, 236, 62.4, 23.2, 99.2, 237, 33.5),
        (3.95, 235, 62.3, 23.0, 99.0, 235, 33.3),
        (3.96, 234, 62.2, 22.8, 98.9, 234, 33.1),
        (3.97, 232, 62.1, 22.6, 98.7, 233, 33.0),
        (3.98, 231, 62.0, 22.4, 98.6, 231, 32.8),
        (3.99, 230, 61.9, 22.2, 98.4, 230, 32.6),
        (4.0, 229, 61.8, 22.0, 98.2, 229, 32.5),
        (4.01, 228, 61.7, 21.8, 98.1, 228, 32.3),
        (4.02, 226, 61.6, 21.6, 97.9, 227, 32.1),
        (4.03, 225, 61.5, 21.5, 97.7, 225, 32.0),
        (4.04, 224, 61.4, 21.3, 97.6, 224, 31.8),
        (4.05, 223, 61.3, 21.1, 97.4, 223, 31.6),
        (4.06, 222, 61.1, 20.9, 97.2, 222, 31.5),
        (4.07, 221, 61.0, 20.7, 97.0, 221, 31.3),
        (4.08, 219, 60.9, 20.5, 96.9, 219, 31.2),
        (4.09, 218, 60.8, 20.3, 96.7, 218, 31.0),
        (4.1, 217, 60.7, 20.1, 96.5, 217, 30.9),
        (4.11, 216, 60.6, 19.9, 96.3, 216, 30.7),
        (4.12, 215, 60.5, 19.7, 96.1, 215, 30.6),
        (4.13, 214, 60.4, 19.5, 95.9, 214, 30.4),
        (4.14, 213, 60.3, 19.2, 95.7, 213, 30.3),
        (4.15, 212, 60.1, 19.0, 95.5, 212, 30.1),
        (4.16, 211, 60.0, 18.8, 95.4, 211, 30.0),
        (4.17, 210, 59.9, 18.6, 95.2, 209, 29.8),
        (4.18, 209, 59.8, 18.3, 95.0, 208, 29.7),
        (4.19, 208, 59.7, 18.1, 94.8, 207, 29.6),
        (4.2, 206, 59.6, 17.9, 94.6, 206, 29.4),
        (4.21, 205, 59.4, None, 94.4, 205, 29.3),
        (4.22, 204, 59.3, None, 94.2, 204, 29.2),
        (4.23, 203, 59.2, None, 94.0, 203, 29.0),
        (4.24, 202, 59.1, None, 93.8, 202, 28.9),
        (4.25, 201, 59.0, None, 93.6, 201, 28.8),
        (4.26, 200, 58.8, None, 93.4, 200, 28.6),
        (4.27, 199, 58.7, None, 93.2, 199, 28.5),
        (4.28, 198, 58.6, None, 93.0, 198, 28.4),
        (4.29, 197, 58.5, None, 92.8, 197, 28.3),
        (4.3, 197, 58.4, None, 92.6, 196, 28.1),
        (4.31, 196, 58.2, None, 92.4, 195, 28.0),
        (4.32, 195, 58.1, None, 92.2, 194, 27.9),
        (4.33, 194, 58.0, None, 92.0, 193, 27.8),
        (4.34, 193, 57.9, None, 91.8, 192, 27.6),
        (4.35, 192, 57.7, None, 91.6, 191, 27.5),
        (4.36, 191, 57.6, None, 91.3, 190, 27.4),
        (4.37, 190, 57.5, None, 91.1, 189, 27.3),
        (4.38, 189, 57.4, None, 90.9, 188, 27.2),
        (4.39, 188, 57.2, None, 90.7, 187, 27.0),
        (4.4, 187, 57.1, None, 90.5, 186, 26.9),
        (4.41, 186, 57.0, None, 90.3, 185, 26.8),
        (4.42, 185, 56.9, None, 90.1, 184, 26.7),
        (4.43, 185, 56.8, None, 89.9, 183, 26.6),
        (4.44, 184, 56.6, None, 89.7, 183, 26.4),
        (4.45, 183, 56.5, None, 89.5, 182, 26.3),
        (4.46, 182, 56.4, None, 89.3, 181, 26.2),
        (4.47, 181, 56.3, None, 89.1, 180, 26.1),
        (4.48, 180, 56.1, None, 88.8, 179, 26.0),
        (4.49, 179, 56.0, None, 88.6, 178, 25.8),
        (4.5, 179, 55.9, None, 88.4, 177, 25.7),
        (4.51, 178, 55.8, None, 88.2, 176, 25.6),
        (4.52, 177, 55.6, None, 88.0, 175, 25.5),
        (4.53, 176, 55.5, None, 87.8, 175, 25.3),
        (4.54, 175, 55.4, None, 87.6, 174, 25.2),
        (4.55, 174, 55.3, None, 87.4, 173, 25.1),
        (4.56, 174, 55.1, None, 87.1, 172, 25.0),
        (4.57, 173, 55.0, None, 86.9, 171, 24.9),
        (4.58, 172, 54.9, None, 86.7, 171, 24.7),
        (4.59, 171, 54.8, None, 86.5, 170, 24.6),
        (4.6, 170, 54.6, None, 86.3, 169, 24.5),
        (4.61, 170, 54.5, None, 86.1, 168, 24.4),
        (4.62, 169, 54.4, None, 85.9, 167, 24.2),
        (4.63, 168, 54.3, None, 85.6, 167, 24.1),
        (4.64, 167, 54.1, None, 85.4, 166, 24.0),
        (4.65, 167, 54.0, None, 85.2, 165, 23.9),
        (4.66, 166, 53.9, None, 85.0, 164, 23.7),
        (4.67, 165, 53.8, None, 84.8, 164, 23.6),
        (4.68, 164, 53.6, None, 84.6, 163, 23.5),
        (4.69, 164, 53.5, None, 84.3, 162, 23.4),
        (4.7, 163, 53.4, None, 84.1, 162, 23.2),
        (4.71, 162, 53.3, None, 83.9, 161, 23.1),
        (4.72, 161, 53.2, None, 83.7, 160, 23.0),
        (4.73, 161, 53.0, None, 83.5, 160, 22.9),
        (4.74, 160, 52.9, None, 83.2, 159, 22.7),
        (4.75, 159, 52.8, None, 83.0, 158, 22.6),
        (4.76, 158, 52.7, None, 82.8, 158, 22.5),
        (4.77, 158, 52.6, None, 82.6, 157, 22.4),
        (4.78, 157, 52.4, None, 82.4, 156, 22.3),
        (4.79, 156, 52.3, None, 82.1, 156, 22.1),
        (4.8, 156, 52.2, None, 81.9, 155, 22.0),
        (4.81, 155, 52.1, None, 81.7, 154, 21.9),
        (4.82, 154, 52.0, None, 81.5, 154, 21.8),
        (4.83, 154, 51.8, None, 81.3, 153, 21.7),
        (4.84, 153, 51.7, None, 81.0, 153, 21.6),
        (4.85, 152, 51.6, None, 80.8, 152, 21.5),
        (4.86, 152, 51.5, None, 80.6, 151, 21.4),
        (4.87, 151, 51.3, None, 80.4, 151, 21.3),
        (4.88, 150, 51.2, None, 80.1, 150, 21.2),
        (4.89, 150, 51.1, None, 79.9, 150, 21.1),
        (4.9, 149, 51.0, None, 79.7, 149, 21.0),
        (4.91, 148, 50.9, None, 79.5, 148, 21.0),
        (4.92, 148, 50.7, None, 79.2, 148, 20.9),
        (4.93, 147, 50.6, None, 79.0, 147, 20.8),
        (4.94, 146, 50.5, None, 78.8, 146, 20.8),
        (4.95, 146, 50.4, None, 78.6, 146, 20.7),
        (4.96, 145, 50.2, None, 78.3, 145, 20.7),
        (4.97, 144, 50.1, None, 78.1, 144, 20.7),
        (4.98, 144, 50.0, None, 77.9, 144, 20.6),
        (4.99, 143, 49.8, None, 77.6, 143, 20.6),
        (5.0, 143, None, None, 77.4, 143, 20.6),
        (5.01, 142, None, None, 77.2, 142, None),
        (5.02, 141, None, None, 77.0, 141, None),
        (5.03, 141, None, None, 76.7, 141, None),
        (5.04, 140, None, None, 76.5, 140, None),
        (5.05, 140, None, None, 76.3, 140, None),
        (5.06, 139, None, None, 76.0, 139, None),
        (5.07, 138, None, None, 75.8, 138, None),
        (5.08, 138, None, None, 75.6, 138, None),
        (5.09, 137, None, None, 75.3, 137, None),
        (5.1, 137, None, None, 75.1, 137, None),
        (5.11, 136, None, None, 74.8, 136, None),
        (5.12, 136, None, None, 74.6, 136, None),
        (5.13, 135, None, None, 74.4, 135, None),
        (5.14, 134, None, None, 74.1, 134, None),
        (5.15, 134, None, None, 73.9, 134, None),
        (5.16, 133, None, None, 73.7, 133, None),
        (5.17, 133, None, None, 73.4, 133, None),
        (5.18, 132, None, None, 73.2, 132, None),
        (5.19, 132, None, None, 72.9, 132, None),
        (5.2, 131, None, None, 72.7, 131, None),
        (5.21, 131, None, None, 72.4, 131, None),
        (5.22, 130, None, None, 72.2, 130, None),
        (5.23, 129, None, None, 72.0, 129, None),
        (5.24, 129, None, None, 71.7, 129, None),
        (5.25, 128, None, None, 71.5, 128, None),
        (5.26, 128, None, None, 71.2, 128, None),
        (5.27, 127, None, None, 71.0, 127, None),
        (5.28, 127, None, None, 70.7, 127, None),
        (5.29, 126, None, None, 70.5, 126, None),
        (5.3, 126, None, None, 70.2, 126, None),
        (5.31, 125, None, None, 70.0, 125, None),
        (5.32, 125, None, None, 69.7, 125, None),
        (5.33, 124, None, None, 69.5, 124, None),
        (5.34, 124, None, None, 69.2, 124, None),
        (5.35, 123, None, None, 69.0, 123, None),
        (5.36, 123, None, None, 68.7, 123, None),
        (5.37, 122, None, None, 68.5, 122, None),
        (5.38, 122, None, None, 68.2, 122, None),
        (5.39, 121, None, None, 68.0, 121, None),
        (5.4, 121, None, None, 67.7, 121, None),
        (5.41, 120, None, None, 67.5, 120, None),
        (5.42, 120, None, None, 67.2, 120, None),
        (5.43, 119, None, None, 67.0, 119, None),
        (5.44, 119, None, None, 66.7, 119, None),
        (5.45, 118, None, None, 66.4, 118, None),
        (5.46, 118, None, None, 66.2, 118, None),
        (5.47, 117, None, None, 65.9, 117, None),
        (5.48, 117, None, None, 65.7, 117, None),
        (5.49, 116, None, None, 65.4, 116, None),
        (5.5, 116, None, None, 65.2, 116, None),
        (5.51, 115, None, None, 64.9, 115, None),
        (5.52, 115, None, None, 64.6, 115, None),
        (5.53, 115, None, None, 64.4, 115, None),
        (5.54, 114, None, None, 64.1, 114, None),
        (5.55, 114, None, None, 63.9, 114, None),
        (5.56, 113, None, None, 63.6, 113, None),
        (5.57, 113, None, None, 63.3, 113, None),
        (5.58, 112, None, None, 63.1, 112, None),
        (5.59, 112, None, None, 62.8, 112, None),
        (5.6, 111, None, None, 62.6, 111, None),
        (5.61, 111, None, None, 62.3, 111, None),
        (5.62, 111, None, None, 62.0, 111, None),
        (5.63, 110, None, None, 61.8, 110, None),
        (5.64, 110, None, None, 61.5, 110, None),
        (5.65, 109, None, None, 61.2, 109, None),
        (5.66, 109, None, None, 61.0, 109, None),
        (5.67, 108, None, None, 60.7, 108, None),
        (5.68, 108, None, None, 60.5, 108, None),
        (5.69, 108, None, None, 60.2, 108, None),
        (5.7, 107, None, None, 59.9, 107, None),
        (5.71, 107, None, None, 59.7, 107, None),
        (5.72, 106, None, None, 59.4, 106, None),
        (5.73, 106, None, None, 59.1, 106, None),
        (5.74, 105, None, None, 58.9, 105, None),
        (5.75, 105, None, None, 58.6, 105, None),
        (5.76, 105, None, None, 58.3, 105, None),
        (5.77, 104, None, None, 58.1, 104, None),
        (5.78, 104, None, None, 57.8, 104, None),
        (5.79, 103, None, None, 57.5, 103, None),
        (5.8, 103, None, None, 57.3, 103, None),
        (5.81, 103, None, None, 57.0, 103, None),
        (5.82, 102, None, None, 56.8, 102, None),
        (5.83, 102, None, None, 56.5, 102, None),
        (5.84, 101, None, None, 56.2, 101, None),
        (5.85, 101, None, None, 56.0, 101, None),
        (5.86, 101, None, None, 55.7, 101, None),
        (5.87, 100, None, None, 55.4, 100, None),
        (5.88, 100, None, None, 55.2, 100, None),
        (5.89, 100, None, None, 54.9, 100, None),
        (5.9, 99, None, None, 54.6, None, None),
        (5.91, 99, None, None, 54.4, None, None),
        (5.92, 98, None, None, 54.1, None, None),
        (5.93, 98, None, None, 53.9, None, None),
        (5.94, 98, None, None, 53.6, None, None),
        (5.95, 97, None, None, 53.3, None, None),
        (5.96, 97, None, None, 53.1, None, None),
        (5.97, 97, None, None, 52.8, None, None),
        (5.98, 96, None, None, 52.5, None, None),
        (5.99, 96, None, None, 52.3, None, None),
        (6.0, 95, None, None, 52.0, None, None),
        (6.01, 95, None, None, 51.8, None, None),
        (6.02, 95, None, None, 51.5, None, None),
        (6.03, 94, None, None, 51.2, None, None),
        (6.04, 94, None, None, 51.0, None, None),
        (6.05, 94, None, None, 50.7, None, None),
        (6.06, 93, None, None, 50.5, None, None),
        (6.07, 93, None, None, 50.2, None, None),
        (6.08, 93, None, None, 50.0, None, None),
        (6.09, 92, None, None, 49.7, None, None),
        (6.1, 92, None, None, 49.4, None, None),
        (6.11, 92, None, None, 49.2, None, None),
        (6.12, 91, None, None, 48.9, None, None),
        (6.13, 91, None, None, 48.7, None, None),
        (6.14, 91, None, None, 48.4, None, None),
        (6.15, 90, None, None, 48.2, None, None),
        (6.16, 90, None, None, 47.9, None, None),
        (6.17, 90, None, None, 47.7, None, None),
        (6.18, 89, None, None, 47.4, None, None),
        (6.19, 89, None, None, 47.2, None, None),
        (6.2, 89, None, None, 46.9, None, None),
        (6.21, 88, None, None, 46.7, None, None),
        (6.22, 88, None, None, 46.4, None, None),
        (6.23, 88, None, None, 46.2, None, None),
        (6.24, 87, None, None, 45.9, None, None),
        (6.25, 87, None, None, 45.7, None, None),
        (6.26, 87, None, None, 45.4, None, None),
        (6.27, 86, None, None, 45.2, None, None),
        (6.28, 86, None, None, 44.9, None, None),
        (6.29, 86, None, None, 44.7, None, None),
        (6.3, 85, None, None, 44.4, None, None),
        (6.31, 85, None, None, 44.2, None, None),
        (6.32, 85, None, None, 43.9, None, None),
        (6.33, 85, None, None, 43.7, None, None),
        (6.34, 84, None, None, 43.5, None, None),
        (6.35, 84, None, None, 43.2, None, None),
        (6.36, 84, None, None, 43.0, None, None),
        (6.37, 83, None, None, 42.7, None, None),
        (6.38, 83, None, None, 42.5, None, None),
        (6.39, 83, None, None, 42.2, None, None),
        (6.4, 82, None, None, 42.0, None, None),
        (6.41, 82, None, None, 41.8, None, None),
        (6.42, 82, None, None, 41.5, None, None),
        (6.43, 82, None, None, 41.3, None, None),
        (6.44, 81, None, None, 41.0, None, None),
        (6.45, 81, None, None, 40.8, None, None),
        (6.46, 81, None, None, 40.6, None, None),
        (6.47, 80, None, None, 40.3, None, None),
        (6.48, 80, None, None, 40.1, None, None),
        (6.49, 80, None, None, 39.8, None, None),
        (6.5, 80, None, None, 39.6, None, None),
        (6.51, 79, None, None, 39.4, None, None),
        (6.52, 79, None, None, 39.1, None, None),
        (6.53, 79, None, None, 38.9, None, None),
        (6.54, 79, None, None, 38.6, None, None),
        (6.55, 78, None, None, 38.4, None, None),
        (6.56, 78, None, None, 38.1, None, None),
        (6.57, 78, None, None, 37.9, None, None),
        (6.58, 78, None, None, 37.7, None, None),
        (6.59, 77, None, None, 37.4, None, None),
        (6.6, 77, None, None, 37.2, None, None),
        (6.61, 77, None, None, 36.9, None, None),
        (6.62, 77, None, None, 36.7, None, None),
        (6.63, 76, None, None, 36.4, None, None),
        (6.64, 76, None, None, 36.2, None, None),
        (6.65, 76, None, None, 35.9, None, None),
        (6.66, 76, None, None, 35.7, None, None),
        (6.67, 75, None, None, 35.4, None, None),
        (6.68, 75, None, None, 35.2, None, None),
        (6.69, 75, None, None, 34.9, None, None),
        (6.7, 75, None, None, 34.7, None, None)
    ]

    HARDNESS_IDX = {
        "d10": 0, "HB": 1, "HRA": 2, "HRC": 3, "HRB": 4, "HV": 5, "HSD": 6
    }

    @staticmethod
    def get_system_unit(type_name):
        cfg = UnitManager.REGISTRY.get(type_name)
        return cfg["system_unit"] if cfg else ""

    @staticmethod
    def get_types():
        return list(UnitManager.REGISTRY.keys())

    @staticmethod
    def get_units(type_name):
        if type_name in UnitManager.REGISTRY:
            return list(UnitManager.REGISTRY[type_name]["factors"].keys())
        return []

    # --- ЛОГИКА ИНТЕРПОЛЯЦИИ ТВЕРДОСТИ (ИСПРАВЛЕННАЯ) ---
    @staticmethod
    def _interpolate_hardness(value, col_source_name, col_target_name):
        """
        Ищет значение в таблице, используя линейную интерполяцию.
        Если значение выходит за пределы известных данных для этой пары единиц — возвращает None.
        """
        idx_src = UnitManager.HARDNESS_IDX.get(col_source_name)
        idx_tgt = UnitManager.HARDNESS_IDX.get(col_target_name)

        if idx_src is None or idx_tgt is None:
            return None

        # 1. Собираем только ВАЛИДНЫЕ пары (X, Y) для конкретных двух колонок
        points = []
        for row in UnitManager.HARDNESS_DATA:
            x = row[idx_src]
            y = row[idx_tgt]
            if x is not None and y is not None:
                points.append((float(x), float(y)))

        # 2. Сортируем по X (входной величине)
        points.sort(key=lambda p: p[0])

        if not points:
            return None

        # 3. ПРОВЕРКА ГРАНИЦ (ИСПРАВЛЕНО)
        # Если значение меньше минимума или больше максимума, определенного в таблице,
        # значит конвертация невозможна (шкала не поддерживает такую твердость).
        min_x = points[0][0]
        max_x = points[-1][0]

        if value < min_x or value > max_x:
            return None  # Вернет 0.0 в методах to_system/from_system

        # 4. Линейная интерполяция внутри диапазона
        for i in range(len(points) - 1):
            x1, y1 = points[i]
            x2, y2 = points[i + 1]

            if x1 <= value <= x2:
                if x2 == x1: return y1
                return y1 + (value - x1) * (y2 - y1) / (x2 - x1)

        return points[-1][1]

    # --- КОНВЕРТАЦИЯ В СИСТЕМНУЮ ЕДИНИЦУ (ВХОД) ---
    @staticmethod
    def to_system(value, from_unit, type_name):
        # 1. Спец. обработка для Твердости
        if type_name == "Твердость":
            system_unit = UnitManager.get_system_unit(type_name) # HB
            if from_unit == system_unit:
                return float(value)
            # Перевод: Единица -> HB (по таблице)
            res = UnitManager._interpolate_hardness(float(value), from_unit, system_unit)
            return res if res is not None else 0.0

        # 2. Стандартная обработка
        cfg = UnitManager.REGISTRY.get(type_name)
        if not cfg: return value

        factor = cfg["factors"].get(from_unit)
        if factor is None: return value

        try:
            val = float(value)
        except:
            return 0.0

        if factor == "offset_k": return val - 273.15
        if factor == "offset_f": return (val - 32.0) * 5 / 9

        return val * factor

    # --- КОНВЕРТАЦИЯ ИЗ СИСТЕМНОЙ ЕДИНИЦЫ (ВЫХОД) ---
    @staticmethod
    def from_system(value, to_unit, type_name):
        # 1. Спец. обработка для Твердости
        if type_name == "Твердость":
            system_unit = UnitManager.get_system_unit(type_name) # HB
            if to_unit == system_unit:
                return float(value)
            # Перевод: HB -> Единица (по таблице)
            res = UnitManager._interpolate_hardness(float(value), system_unit, to_unit)
            return res if res is not None else 0.0

        # 2. Стандартная обработка
        cfg = UnitManager.REGISTRY.get(type_name)
        if not cfg: return value

        factor = cfg["factors"].get(to_unit)
        if factor is None: return value

        try:
            val = float(value)
        except:
            return 0.0

        if factor == "offset_k": return val + 273.15
        if factor == "offset_f": return (val * 9 / 5) + 32.0

        return val / factor


class SourceManager:
    """Менеджер источников."""
    FILENAME = "source.json"

    def __init__(self):
        self.app_dir = get_app_directory()
        self.filepath = os.path.join(self.app_dir, self.FILENAME)
        self.sources = []
        self.load()

    def load(self):
        if not os.path.exists(self.filepath):
            self.sources = []
            self.save()
            return
        try:
            with open(self.filepath, 'r', encoding='utf-8') as f:
                self.sources = json.load(f)
        except Exception as e:
            print(f"Ошибка загрузки source.json: {e}")
            self.sources = []

    def save(self):
        try:
            with open(self.filepath, 'w', encoding='utf-8') as f:
                json.dump(self.sources, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Ошибка сохранения source.json: {e}")

    def get_all(self):
        return self.sources

    def get_source_by_id(self, source_id):
        for src in self.sources:
            if src.get("id_source") == source_id: return src
        return None

    def get_name_by_id(self, source_id):
        src = self.get_source_by_id(source_id)
        return src.get("name_source", "Без названия") if src else "Неизвестный источник"

    def add_source(self, name, description="", hyperlink=""):
        new_id = str(uuid.uuid4())
        new_source = {
            "id_source": new_id, "name_source": name, "description": description, "hyperlink": hyperlink,
            "user_name_found": get_username(), "data_found": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "user_name_change": "", "data_change": ""
        }
        self.sources.append(new_source)
        self.save()
        return new_id

    def update_source(self, source_id, name, description, hyperlink):
        src = self.get_source_by_id(source_id)
        if src:
            src.update({"name_source": name, "description": description, "hyperlink": hyperlink,
                        "user_name_change": get_username(),
                        "data_change": datetime.now().strftime("%Y-%m-%d %H:%M:%S")})
            self.save()
            return True
        return False

    def delete_source(self, source_id):
        self.sources = [s for s in self.sources if s.get("id_source") != source_id]
        self.save()


class Material:
    """
    Класс материала. Инкапсулирует доступ к JSON-структуре.
    Реализует поиск свойств и интерполяцию.
    """

    def __init__(self, filepath=None, data=None):
        self.filepath = filepath
        if filepath:
            with open(filepath, 'r', encoding='utf-8') as f:
                self.data = json.load(f)
        elif data:
            self.data = data
        else:
            self.data = self.get_empty_structure()
        self.filename = os.path.basename(self.filepath) if self.filepath else "Новый материал.json"

    def get_name(self):
        return self.data.get(Schema.METADATA, {}).get(Schema.NAME_STD, "Без имени")

    def get_display_name(self):
        meta = self.data.get(Schema.METADATA, {})
        std = meta.get(Schema.NAME_STD, "Без имени")
        alts = [a.strip() for a in meta.get(Schema.NAME_ALT, []) if a.strip()]
        return f"{std} ({', '.join(alts)})" if alts else std

    @staticmethod
    def get_empty_structure():
        return {
            "material_id": str(uuid.uuid4()),
            Schema.METADATA: {
                Schema.NAME_STD: "", Schema.NAME_ALT: [], Schema.APP_AREA: [], "comment": "",
                "classification": {"classification_category": "", "classification_class": "",
                                   "classification_subclass": ""}
            },
            Schema.PHYSICAL: {},
            Schema.MECHANICAL: {Schema.STRENGTH_CAT: []},
            Schema.CHEMICAL: {Schema.COMPOSITION: []}
        }

    def get_strength_categories(self):
        """Возвращает список категорий прочности."""
        return self.data.get(Schema.MECHANICAL, {}).get(Schema.STRENGTH_CAT, [])

    def get_interpolated_property(self, prop_key, temp, category_idx=None):
        """
        Универсальный метод получения значения свойства при температуре.
        Ищет сначала в физических, затем в механических (по категории).
        """
        # 1. Поиск в физических свойствах
        phys_props = self.data.get(Schema.PHYSICAL, {})
        if prop_key in phys_props:
            pairs = phys_props[prop_key].get(Schema.TEMP_PAIRS, [])
            val = MathUtils.linear_interpolate(pairs, temp)
            if val is not None: return val

        # 2. Поиск в механических свойствах
        cats = self.get_strength_categories()

        # Если категория задана индексом
        target_cats = [cats[category_idx]] if category_idx is not None and 0 <= category_idx < len(cats) else cats

        for cat in target_cats:
            if prop_key in cat:
                pairs = cat[prop_key].get(Schema.TEMP_PAIRS, [])
                val = MathUtils.linear_interpolate(pairs, temp)
                if val is not None: return val

        return None

    def get_source_info(self, prop_type, prop_key=None, category_idx=None, source_manager=None):
        """Получает текстовое описание источника для свойства."""

        def resolve_name(container):
            rid = container.get(Schema.REF_ID)
            if rid and source_manager: return source_manager.get_name_by_id(rid)
            return None

        if prop_type == Schema.PHYSICAL:
            container = self.data.get(Schema.PHYSICAL, {})
            name = resolve_name(container)
            if not name:  # Ищем внутри свойства
                if prop_key and prop_key in container:
                    return container[prop_key].get("property_source", "-")
            return name or "-"

        if prop_type == Schema.MECHANICAL:
            cats = self.get_strength_categories()
            if not cats: return "-"
            # Берем первую или указанную категорию
            cat = cats[category_idx] if category_idx is not None and 0 <= category_idx < len(cats) else cats[0]
            name = resolve_name(cat)
            if not name and prop_key and prop_key in cat:
                return cat[prop_key].get("property_source", "-")
            return name or "-"

        return "-"

    def save(self, filepath=None):
        save_path = filepath or self.filepath
        if not save_path: raise ValueError("Путь не указан")
        self.filepath = save_path
        self.filename = os.path.basename(save_path)
        now = datetime.now().isoformat()

        # Обновление времени изменения
        for prop in self.data.get(Schema.PHYSICAL, {}).values():
            if "property_name" in prop: prop["property_last_updated"] = now
        for cat in self.get_strength_categories():
            for k, v in cat.items():
                if isinstance(v, dict) and "property_name" in v: v["property_last_updated"] = now

        with open(save_path, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)


class AppData:
    """Состояние приложения."""

    def __init__(self):
        self.work_dir = ""
        self.materials = []
        self.application_areas = []
        self.current_material = None
        self.source_manager = SourceManager()

    def load_materials_from_dir(self, directory):
        self.work_dir = directory
        self.materials.clear()
        if not os.path.isdir(directory): return

        for filename in os.listdir(directory):
            if filename.endswith('.json') and filename != "source.json":
                try:
                    mat = Material(filepath=os.path.join(directory, filename))
                    self.materials.append(mat)
                except Exception as e:
                    print(f"Ошибка чтения {filename}: {e}")
        self.materials.sort(key=lambda m: m.get_display_name())
        self.load_application_areas()

    def load_application_areas(self):
        all_areas = set()
        for m in self.materials:
            all_areas.update(m.data.get(Schema.METADATA, {}).get(Schema.APP_AREA, []))
        self.application_areas = sorted(list(all_areas))


# ======================================================================================
# БЛОК 4: UI HELPERS
# ======================================================================================


class CustomToolbar(NavigationToolbar2Tk):
    """
    Пользовательская панель инструментов, которая при нажатии 'Home'
    перерисовывает график, вызывая внешнюю функцию.
    """
    def __init__(self, canvas, window, plot_callback):
        super().__init__(canvas, window)
        # Сохраняем ссылку на нашу функцию для построения графика
        self.plot_callback = plot_callback

    def home(self, *args, **kwargs):
        """
        Переопределяем стандартное поведение кнопки 'Home'.
        Вместо сброса вида, мы полностью перерисовываем график.
        """
        # Вызываем нашу функцию, которая всё сделает сама
        self.plot_callback()


class Tooltip:
    def __init__(self, widget, text, delay=500):
        self.widget = widget
        self.text = text
        self.delay = delay
        self.tip_window = None
        self.id = None
        self.widget.bind("<Enter>", self.schedule_tip)
        self.widget.bind("<Leave>", self.hide_tip)
    def schedule_tip(self, event=None):
        self.id = self.widget.after(self.delay, self.show_tip)
    def show_tip(self, event=None):
        if self.tip_window or not self.text: return
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        self.tip_window = tk.Toplevel(self.widget)
        self.tip_window.wm_overrideredirect(True)
        self.tip_window.wm_geometry(f"+{x}+{y}")
        label = tk.Label(self.tip_window, text=self.text, justify=tk.LEFT,
                         background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                         font=("TkDefaultFont", 10, "normal"), wraplength=300)
        label.pack(ipadx=5, ipady=3)
    def hide_tip(self, event=None):
        if self.id: self.widget.after_cancel(self.id); self.id = None
        if self.tip_window: self.tip_window.destroy(); self.tip_window = None


def create_editable_treeview(parent_frame, on_update_callback=None):
    tree = ttk.Treeview(parent_frame)
    def on_tree_double_click(event):
        region = tree.identify("region", event.x, event.y)
        if region != "cell": return
        item_id = tree.focus()
        column = tree.identify_column(event.x)
        x, y, width, height = tree.bbox(item_id, column)
        entry_var = tk.StringVar()
        entry = ttk.Entry(tree, textvariable=entry_var)
        entry_var.set(tree.set(item_id, column))
        entry.place(x=x, y=y, width=width, height=height)
        entry.focus_set()
        entry.selection_range(0, tk.END)
        def on_focus_out(event):
            tree.set(item_id, column, entry_var.get())
            entry.destroy()
            if on_update_callback: on_update_callback()
        entry.bind("<FocusOut>", on_focus_out)
        entry.bind("<Return>", lambda e: on_focus_out(e))
    tree.bind("<Double-1>", on_tree_double_click)
    return tree


# ======================================================================================
# БЛОК 5: ВКЛАДКИ ПРОСМОТРА (VIEWER)
# ======================================================================================


class TempSelectionTab(ttk.Frame, ScrollableMixin):
    """Вкладка 'Подбор по температуре' с фиксированными колонками и синхронным скроллом."""

    def __init__(self, parent, app_data):
        super().__init__(parent)
        self.app_data = app_data
        self.treeview_data = []
        self.column_units = {}
        self.PROP_TYPES = ["Физические свойства", "Механические свойства", "Твердость"]
        self.PROPERTY_COLUMN_WIDTH = 100
        self.HARDNESS_COLUMNS = {
            "min_value": {"name": "Min", "width": self.PROPERTY_COLUMN_WIDTH, "unit_type": "Твердость"},
            "max_value": {"name": "Max", "width": self.PROPERTY_COLUMN_WIDTH, "unit_type": "Твердость"},
            "unit_value": {"name": "Ед. изм.", "width": self.PROPERTY_COLUMN_WIDTH}
        }
        self._after_id = None
        style = ttk.Style()
        style.configure("Treeview.Heading", padding=(5, 5), wraplength=120, font=('TkDefaultFont', 9))
        style.map("Treeview", background=[("selected", "gray")], foreground=[("selected", "white")])
        self._setup_widgets()
        self._setup_treeview()
        self._reconfigure_scrollable_treeview(self.PROP_TYPES[0])

    def _setup_widgets(self):
        controls_frame = ttk.Frame(self)
        controls_frame.pack(fill="x", padx=10, pady=10)
        ttk.Label(controls_frame, text="Тип свойств:").pack(side="left", padx=(0, 5))
        self.prop_type_combo = ttk.Combobox(controls_frame, state="readonly", width=20, values=self.PROP_TYPES)
        self.prop_type_combo.pack(side="left", padx=5)
        self.prop_type_combo.set(self.PROP_TYPES[0])
        self.prop_type_combo.bind("<<ComboboxSelected>>", self._trigger_calculate)
        ttk.Label(controls_frame, text="Область применения:").pack(side="left", padx=(10, 5))
        self.area_combo = ttk.Combobox(controls_frame, state="readonly", width=30)
        self.area_combo.pack(side="left", padx=5)
        self.area_combo.bind("<<ComboboxSelected>>", self._trigger_calculate)
        ttk.Label(controls_frame, text="Температура, °С:").pack(side="left", padx=(20, 5))
        self.temp_entry = ttk.Entry(controls_frame, width=10)
        self.temp_entry.pack(side="left", padx=5)
        self.temp_entry.insert(0, "20")
        self.temp_entry.bind("<KeyRelease>", self._trigger_calculate)

        lbl_hint = ttk.Label(controls_frame, text="(ПКМ по заголовку для смены ед.изм.)", foreground="gray")
        lbl_hint.pack(side="right", padx=10)

    def _setup_treeview(self):
        tree_container = ttk.Frame(self)
        tree_container.pack(expand=True, fill="both", padx=10, pady=(0, 10))
        tree_container.grid_rowconfigure(0, weight=1)
        tree_container.grid_columnconfigure(1, weight=1)

        frozen_columns = ["material_name", "strength_category", "source", "max_temp"]
        self.tree_frozen = ttk.Treeview(tree_container, columns=frozen_columns, show="headings")
        self.tree_scrollable = ttk.Treeview(tree_container, columns=[], show="headings")

        self.tree_frozen.grid(row=0, column=0, sticky="nswe")
        self.tree_scrollable.grid(row=0, column=1, sticky="nswe")

        # --- ВОССТАНОВЛЕНЫ ШИРИНЫ КОЛОНОК ---
        self.tree_frozen.heading("material_name", text="Материал",
                                 command=lambda: self._sort_column("material_name", False))
        self.tree_frozen.column("material_name", width=150, minwidth=150)

        self.tree_frozen.heading("strength_category", text="КП",
                                 command=lambda: self._sort_column("strength_category", False))
        self.tree_frozen.column("strength_category", width=50, minwidth=50)

        self.tree_frozen.heading("source", text="НТД", command=lambda: self._sort_column("source", False))
        self.tree_frozen.column("source", width=120, minwidth=120)

        self.tree_frozen.heading("max_temp", text="tприм ДО, °С",
                                 command=lambda: self._sort_column("max_temp", False))
        self.tree_frozen.column("max_temp", width=100, minwidth=100, anchor="center")

        # Скроллбары
        vsb = ttk.Scrollbar(tree_container, orient="vertical", command=self._on_vertical_scroll)
        vsb.grid(row=0, column=2, sticky="ns")
        hsb = ttk.Scrollbar(tree_container, orient="horizontal", command=self.tree_scrollable.xview)
        hsb.grid(row=1, column=1, sticky="ew")

        self.tree_frozen.configure(yscrollcommand=vsb.set)
        self.tree_scrollable.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        # --- СИНХРОННЫЙ СКРОЛЛ КОЛЕСОМ ---
        # Мы не используем Mixin здесь, так как логика сложнее (два дерева сразу)
        self.tree_frozen.bind("<MouseWheel>", self._on_mousewheel)
        self.tree_scrollable.bind("<MouseWheel>", self._on_mousewheel)
        self.tree_frozen.bind("<Button-4>", lambda e: self._on_mousewheel(e, -1))
        self.tree_frozen.bind("<Button-5>", lambda e: self._on_mousewheel(e, 1))
        self.tree_scrollable.bind("<Button-4>", lambda e: self._on_mousewheel(e, -1))
        self.tree_scrollable.bind("<Button-5>", lambda e: self._on_mousewheel(e, 1))

        # Контекстное меню
        self.context_menu = tk.Menu(self, tearoff=0)
        self.context_menu.add_command(label="Копировать", command=self._copy_cell_value)
        self.last_clicked_tree = None
        self.tree_frozen.bind("<Button-3>", self._show_context_menu)
        self.tree_scrollable.bind("<Button-3>", self._on_scrollable_right_click)

    def _trigger_calculate(self, event=None):
        if self._after_id:
            self.after_cancel(self._after_id)
        self._after_id = self.after(300, self._on_calculate)

    # Специальный метод скролла для этой вкладки
    def _on_vertical_scroll(self, *args):
        self.tree_frozen.yview(*args)
        self.tree_scrollable.yview(*args)

    # Специальный метод колеса для этой вкладки
    def _on_mousewheel(self, event, delta_direction=None):
        delta = delta_direction if delta_direction else (
            -1 * (event.delta // 120) if hasattr(event, 'delta') else (1 if event.num == 5 else -1))
        self.tree_frozen.yview_scroll(delta, "units")
        self.tree_scrollable.yview_scroll(delta, "units")
        return "break"

    def _reconfigure_scrollable_treeview(self, prop_type):
        self.tree_scrollable["columns"] = []
        self.column_units.clear()

        prop_map = {}
        if prop_type == "Физические свойства":
            prop_map = PHYSICAL_PROPERTIES_MAP
        elif prop_type == "Механические свойства":
            prop_map = MECHANICAL_PROPERTIES_MAP
        elif prop_type == "Твердость":
            prop_map = self.HARDNESS_COLUMNS

        new_columns = list(prop_map.keys())
        self.tree_scrollable["columns"] = new_columns

        for prop_key, prop_info in prop_map.items():
            base_unit = prop_info.get('unit', '')
            unit_type = prop_info.get("unit_type")
            if unit_type:
                available = UnitManager.get_units(unit_type)
                if base_unit in available:
                    self.column_units[prop_key] = base_unit
                else:
                    self.column_units[prop_key] = UnitManager.get_system_unit(unit_type)
            else:
                self.column_units[prop_key] = base_unit

            self._update_column_header(prop_key, prop_info)
            self.tree_scrollable.column(prop_key, width=self.PROPERTY_COLUMN_WIDTH, minwidth=80, anchor="center")

    def _update_column_header(self, prop_key, prop_info=None):
        if not prop_info:
            current_type = self.prop_type_combo.get()
            if current_type == "Физические свойства":
                prop_info = PHYSICAL_PROPERTIES_MAP.get(prop_key)
            elif current_type == "Механические свойства":
                prop_info = MECHANICAL_PROPERTIES_MAP.get(prop_key)
            elif current_type == "Твердость":
                prop_info = self.HARDNESS_COLUMNS.get(prop_key)

        if not prop_info: return
        current_unit = self.column_units.get(prop_key, prop_info.get('unit', ''))
        header_text = prop_info.get('symbol', prop_info.get('name', prop_key))
        if current_unit:
            header_text += f", {current_unit}"
        self.tree_scrollable.heading(prop_key, text=header_text,
                                     command=lambda k=prop_key: self._sort_column(k, False))

    def _on_scrollable_right_click(self, event):
        region = self.tree_scrollable.identify_region(event.x, event.y)
        if region == "heading":
            col_id = self.tree_scrollable.identify_column(event.x)
            col_index = int(col_id.replace('#', '')) - 1
            columns = self.tree_scrollable["columns"]
            if 0 <= col_index < len(columns):
                self._show_header_unit_menu(event, columns[col_index])
        else:
            self._show_context_menu(event)

    def _show_header_unit_menu(self, event, prop_key):
        current_type = self.prop_type_combo.get()
        prop_info = {}
        if current_type == "Физические свойства":
            prop_info = PHYSICAL_PROPERTIES_MAP.get(prop_key)
        elif current_type == "Механические свойства":
            prop_info = MECHANICAL_PROPERTIES_MAP.get(prop_key)
        elif current_type == "Твердость":
            prop_info = self.HARDNESS_COLUMNS.get(prop_key)

        if not prop_info: return
        unit_type = prop_info.get("unit_type")
        if not unit_type: return

        available_units = UnitManager.get_units(unit_type)
        if not available_units: return

        menu = tk.Menu(self, tearoff=0)
        current_unit = self.column_units.get(prop_key)

        for unit in available_units:
            menu.add_radiobutton(label=unit, value=unit, variable=tk.StringVar(value=current_unit),
                                 command=lambda u=unit: self._change_column_unit(prop_key, u))
        menu.post(event.x_root, event.y_root)

    def _change_column_unit(self, prop_key, new_unit):
        if self.column_units.get(prop_key) == new_unit: return
        self.column_units[prop_key] = new_unit
        self._update_column_header(prop_key)
        self._populate_treeview()

    def _get_value_from_prop_data(self, prop_data, temp):
        if not prop_data or "temperature_value_pairs" not in prop_data: return None
        pairs = sorted(prop_data.get("temperature_value_pairs", []), key=lambda p: p[0])
        if not pairs: return None
        for t, val in pairs:
            if t == temp: return float(val)
        lower_point, upper_point = None, None
        for t, val in pairs:
            try:
                t_float, v_float = float(t), float(val)
                if t_float < temp:
                    lower_point = (t_float, v_float)
                elif t_float > temp:
                    upper_point = (t_float, v_float)
                    break
            except (ValueError, TypeError):
                continue
        if lower_point and upper_point:
            t1, v1 = lower_point;
            t2, v2 = upper_point
            if t2 - t1 == 0: return v1
            return v1 + (temp - t1) * (v2 - v1) / (t2 - t1)
        return None

    def _on_calculate(self):
        selected_prop_type = self.prop_type_combo.get()
        current_cols = self.tree_scrollable["columns"]

        is_phys = (selected_prop_type == "Физические свойства")
        is_mech = (selected_prop_type == "Механические свойства")
        is_hard = (selected_prop_type == "Твердость")

        prop_map = {}
        if is_phys:
            prop_map = PHYSICAL_PROPERTIES_MAP
        elif is_mech:
            prop_map = MECHANICAL_PROPERTIES_MAP
        elif is_hard:
            prop_map = self.HARDNESS_COLUMNS

        if list(current_cols) != list(prop_map.keys()):
            self._reconfigure_scrollable_treeview(selected_prop_type)

        temp = MathUtils.safe_float(self.temp_entry.get(), default=0.0)
        selected_area = self.area_combo.get()

        filtered_materials = [
            m for m in self.app_data.materials
            if selected_area == "Все" or selected_area in m.data.get(Schema.METADATA, {}).get(Schema.APP_AREA, [])
        ]

        self.treeview_data = []

        for mat in filtered_materials:
            max_app_temp = mat.data.get(Schema.METADATA, {}).get("temperature_application", {}).get("value", "-")
            cats = mat.get_strength_categories()

            if is_hard:
                # Логика твердости сложная, оставляем ручной перебор, но через константы
                if cats:
                    for cat in cats:
                        h_list = cat.get("hardness", [])
                        if h_list:
                            for h in h_list:
                                src = h.get("property_source", "") + (
                                    f" ({h.get('property_subsource')})" if h.get("property_subsource") else "")
                                self.treeview_data.append({
                                    "material_name": mat.get_display_name(), "obj": mat,
                                    "strength_category": cat.get(Schema.VAL_STR_CAT, "N/A"),
                                    "source": src or "-", "max_temp": max_app_temp,
                                    "min_value": h.get("min_value"), "max_value": h.get("max_value"),
                                    "unit_value": h.get("unit_value", "-")
                                })
                        else:
                            self.treeview_data.append({"material_name": mat.get_display_name(),
                                                       "strength_category": cat.get(Schema.VAL_STR_CAT), "source": "-",
                                                       "max_temp": max_app_temp, "min_value": None})
                else:
                    self.treeview_data.append(
                        {"material_name": mat.get_display_name(), "strength_category": "-", "source": "-",
                         "max_temp": max_app_temp, "min_value": None})
            else:
                # Физические и Механические
                if cats and not is_phys:  # Для механики разбиваем по категориям
                    for i, cat in enumerate(cats):
                        source_str = mat.get_source_info(Schema.MECHANICAL if is_mech else Schema.PHYSICAL,
                                                         category_idx=i, source_manager=self.app_data.source_manager)
                        row = {
                            "material_name": mat.get_display_name(), "obj": mat,
                            "strength_category": cat.get(Schema.VAL_STR_CAT, "N/A"),
                            "source": source_str, "max_temp": max_app_temp
                        }
                        for prop_key in prop_map:
                            # ! ВЫЗОВ НОВОГО МЕТОДА !
                            val = mat.get_interpolated_property(prop_key, temp, category_idx=i)
                            row[prop_key] = val
                        self.treeview_data.append(row)
                else:
                    # Физ свойства (одна строка на материал)
                    source_str = mat.get_source_info(Schema.PHYSICAL, source_manager=self.app_data.source_manager)
                    row = {
                        "material_name": mat.get_display_name(), "obj": mat,
                        "strength_category": "-", "source": source_str, "max_temp": max_app_temp
                    }
                    for prop_key in prop_map:
                        # ! ВЫЗОВ НОВОГО МЕТОДА !
                        val = mat.get_interpolated_property(prop_key, temp)
                        row[prop_key] = val
                    self.treeview_data.append(row)

        self._populate_treeview()

    def _populate_treeview(self):
        for i in self.tree_frozen.get_children(): self.tree_frozen.delete(i)
        for i in self.tree_scrollable.get_children(): self.tree_scrollable.delete(i)

        scrollable_cols = self.tree_scrollable["columns"]
        frozen_cols = self.tree_frozen["columns"]

        prop_map = {}
        current_type = self.prop_type_combo.get()
        if current_type == "Физические свойства":
            prop_map = PHYSICAL_PROPERTIES_MAP
        elif current_type == "Механические свойства":
            prop_map = MECHANICAL_PROPERTIES_MAP
        elif current_type == "Твердость":
            prop_map = self.HARDNESS_COLUMNS

        for row in self.treeview_data:
            frozen_values = [str(row.get(c, "-") if row.get(c) is not None else "-") for c in frozen_cols]
            scrollable_values = []
            for col_key in scrollable_cols:
                raw_val = row.get(col_key)
                if col_key == "unit_value":
                    scrollable_values.append(str(raw_val) if raw_val else "-")
                    continue
                if raw_val is None:
                    scrollable_values.append("-")
                    continue

                prop_info = prop_map.get(col_key)
                if prop_info and "unit_type" in prop_info:
                    unit_type = prop_info["unit_type"]
                    source_unit = prop_info.get("unit")
                    if unit_type == "Твердость": source_unit = row.get("unit_value")
                    target_unit = self.column_units.get(col_key, source_unit)

                    if source_unit and target_unit and unit_type:
                        try:
                            sys_val = UnitManager.to_system(raw_val, source_unit, unit_type)
                            final_val = UnitManager.from_system(sys_val, target_unit, unit_type)
                            scrollable_values.append(f"{final_val:.2f}")
                        except Exception:
                            scrollable_values.append(f"{raw_val:.2f}")
                    else:
                        scrollable_values.append(f"{raw_val:.2f}")
                else:
                    scrollable_values.append(f"{raw_val:.2f}")

            self.tree_frozen.insert("", "end", values=frozen_values)
            self.tree_scrollable.insert("", "end", values=scrollable_values)

    def _sort_column(self, col, reverse):
        def get_sort_key(item):
            value = item.get(col)
            if value is None: return (2, None)
            if isinstance(value, (int, float)): return (0, value)
            return (1, str(value).lower())

        self.treeview_data.sort(key=get_sort_key, reverse=reverse)
        self._populate_treeview()
        tree_to_bind = self.tree_frozen if col in self.tree_frozen['columns'] else self.tree_scrollable
        tree_to_bind.heading(col, command=lambda: self._sort_column(col, not reverse))

    def update_comboboxes(self):
        areas = ["Все"] + self.app_data.application_areas
        self.area_combo.config(values=areas)
        if not self.area_combo.get(): self.area_combo.set("Все")
        if not self.prop_type_combo.get(): self.prop_type_combo.set(self.PROP_TYPES[0])
        self._trigger_calculate()

    def _show_context_menu(self, event):
        self.last_clicked_tree = event.widget
        item_id = self.last_clicked_tree.identify_row(event.y)
        if item_id:
            self.last_clicked_tree.focus(item_id)
            self.last_clicked_tree.selection_set(item_id)
        self.context_menu.post(event.x_root, event.y_root)

    def _copy_cell_value(self):
        tree = self.last_clicked_tree
        if not tree or not tree.focus(): return
        item = tree.focus()
        col = tree.identify_column(self.winfo_pointerx() - tree.winfo_rootx())
        col_index = int(col.replace('#', '')) - 1
        try:
            value = tree.item(item, "values")[col_index]
            self.clipboard_clear()
            self.clipboard_append(value)
        except (IndexError, tk.TclError):
            pass


class SingleCalculationTab(ttk.Frame, ScrollableMixin):
    """
    Вкладка-справочник + Калькулятор точки.
    Особенности:
    - Скрытие/показ колонок.
    - Увеличенная высота заголовков.
    - Интерполяция произвольной точки (без экстраполяции).
    - Автопересчет при смене материала.
    """

    def __init__(self, parent, app_data):
        super().__init__(parent)
        self.app_data = app_data
        self.column_units = {}
        self.column_visibility = {k: True for k in list(PHYSICAL_PROPERTIES_MAP.keys()) + list(MECHANICAL_PROPERTIES_MAP.keys())}
        self.ALL_KEYS = list(PHYSICAL_PROPERTIES_MAP.keys()) + list(MECHANICAL_PROPERTIES_MAP.keys())
        self.db_data_rows = []
        self.custom_temps = []
        style = ttk.Style()
        style.configure("BigHeader.Treeview.Heading", padding=(5, 10, 5, 10), font=('TkDefaultFont', 9, 'bold'))
        style.configure("BigHeader.Treeview", rowheight=25)
        self._setup_widgets()

    def _setup_widgets(self):
        # --- 1. ВЕРХНЯЯ ПАНЕЛЬ ФИЛЬТРОВ ---
        top_frame = ttk.Frame(self, padding=10)
        top_frame.pack(fill="x", side="top")

        row1 = ttk.Frame(top_frame)
        row1.pack(fill="x", pady=(0, 5))

        ttk.Label(row1, text="Область:").pack(side="left", padx=(0, 5))
        self.area_combo = ttk.Combobox(row1, state="readonly", width=20)
        self.area_combo.pack(side="left", padx=5)
        self.area_combo.bind("<<ComboboxSelected>>", self._filter_materials)

        ttk.Label(row1, text="Материал:").pack(side="left", padx=(15, 5))
        self.material_combo = ttk.Combobox(row1, state="readonly", width=35)
        self.material_combo.pack(side="left", padx=5)
        self.material_combo.bind("<<ComboboxSelected>>", self._on_material_select)

        ttk.Label(row1, text="КП:").pack(side="left", padx=(15, 5))
        self.category_combo = ttk.Combobox(row1, state="readonly", width=10)
        self.category_combo.pack(side="left", padx=5)
        self.category_combo.bind("<<ComboboxSelected>>", self._on_category_select)

        row2 = ttk.Frame(top_frame)
        row2.pack(fill="x")

        self.col_btn = ttk.Menubutton(row2, text="Настроить столбцы", direction="below")
        self.col_menu = tk.Menu(self.col_btn, tearoff=0)
        self.col_btn.configure(menu=self.col_menu)
        self.col_btn.pack(side="left")
        self._populate_column_menu()

        ttk.Label(row2, text="(ПКМ по заголовку — смена ед.изм)", foreground="gray").pack(side="right")

        # --- 2. ТАБЛИЦА ---
        tree_frame = ttk.Frame(self)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=0)

        self.tree = ttk.Treeview(tree_frame, show="headings", style="BigHeader.Treeview")

        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")

        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        # Теги для раскраски
        self.tree.tag_configure("custom_calc", background="#ffffe0", foreground="black",
                                font=('TkDefaultFont', 9, 'bold'))
        # Тег для разделительной линии
        self.tree.tag_configure("separator", background="#555555", foreground="white")

        self.tree.bind("<Button-3>", self._on_header_right_click)
        self.bind_mouse_wheel(self.tree)

        # --- 3. НИЖНЯЯ ПАНЕЛЬ (КАЛЬКУЛЯТОР) ---
        calc_frame = ttk.LabelFrame(self, text="Расчет произвольной точки", padding=10)
        calc_frame.pack(fill="x", padx=10, pady=10, side="bottom")

        ttk.Label(calc_frame, text="Температура, °C:").pack(side="left", padx=(0, 5))
        self.calc_temp_entry = ttk.Entry(calc_frame, width=10)
        self.calc_temp_entry.pack(side="left", padx=5)
        self.calc_temp_entry.bind("<Return>", lambda e: self._add_custom_calculation())

        # Кнопка добавления
        add_btn = ttk.Button(calc_frame, text="+ Добавить расчет", command=self._add_custom_calculation)
        add_btn.pack(side="left", padx=15)

        # Кнопка удаления выделенного
        del_btn = ttk.Button(calc_frame, text="- Исключить строку", command=self._remove_selected_custom_row)
        del_btn.pack(side="left", padx=5)

        # Кнопка очистки всего
        clear_btn = ttk.Button(calc_frame, text="Очистить все", command=self._clear_custom_rows)
        clear_btn.pack(side="right")

    def _populate_column_menu(self):
        self.col_menu.delete(0, tk.END)
        self.col_menu.add_command(label="[Показать все]", command=lambda: self._set_all_columns(True))
        self.col_menu.add_command(label="[Скрыть все]", command=lambda: self._set_all_columns(False))
        self.col_menu.add_separator()

        for key in self.ALL_KEYS:
            if key in PHYSICAL_PROPERTIES_MAP:
                name = PHYSICAL_PROPERTIES_MAP[key]['symbol']
            else:
                name = MECHANICAL_PROPERTIES_MAP[key]['symbol']

            is_visible = self.column_visibility[key]
            self.col_menu.add_checkbutton(
                label=name, onvalue=1, offvalue=0,
                variable=tk.IntVar(value=1 if is_visible else 0),
                command=lambda k=key: self._toggle_column(k)
            )

    def _toggle_column(self, key):
        self.column_visibility[key] = not self.column_visibility[key]
        self._populate_column_menu()
        self._render_table()

    def _set_all_columns(self, visible):
        for k in self.column_visibility:
            self.column_visibility[k] = visible
        self._populate_column_menu()
        self._render_table()

    # --- ЛОГИКА ---

    def update_comboboxes(self):
        areas = ["Все"] + self.app_data.application_areas
        self.area_combo.config(values=areas)
        if not self.area_combo.get(): self.area_combo.set("Все")
        self._filter_materials()

    def _filter_materials(self, event=None):
        selected_area = self.area_combo.get()
        mats = []
        for m in self.app_data.materials:
            if selected_area == "Все" or selected_area in m.data.get("metadata", {}).get("application_area", []):
                mats.append(m.get_display_name())

        self.material_combo.config(values=mats)
        if mats:
            self.material_combo.current(0)
            self._on_material_select()
        else:
            self.material_combo.set("")
            self.category_combo.set("")
            self._clear_db_data()

    def _on_material_select(self, event=None):
        mat_name = self.material_combo.get()
        material = next((m for m in self.app_data.materials if m.get_display_name() == mat_name), None)
        if not material: return

        cats = material.data.get("mechanical_properties", {}).get("strength_category", [])
        cat_names = [c.get("value_strength_category", "Без названия") for c in cats]

        self.category_combo.config(values=cat_names)
        if cat_names:
            self.category_combo.current(0)
        else:
            self.category_combo.set("")

        self._calculate_db_rows()

    def _on_category_select(self, event=None):
        self._calculate_db_rows()

    def _clear_db_data(self):
        self.db_data_rows = []
        self._render_table()

    def _calculate_db_rows(self):
        """Сбор данных из БД."""
        mat_name = self.material_combo.get()
        material = next((m for m in self.app_data.materials if m.get_display_name() == mat_name), None)
        if not material: return
        cat_idx = self.category_combo.current()

        # Собираем все температуры
        all_temps = set()
        # Из физ свойств
        for pk in PHYSICAL_PROPERTIES_MAP:
            data = material.data.get(Schema.PHYSICAL, {}).get(pk, {})
            for t, v in data.get(Schema.TEMP_PAIRS, []): all_temps.add(t)

        # Из мех свойств
        cats = material.get_strength_categories()
        if cat_idx != -1 and cats:
            for pk in MECHANICAL_PROPERTIES_MAP:
                data = cats[cat_idx].get(pk, {})
                for t, v in data.get(Schema.TEMP_PAIRS, []): all_temps.add(t)

        sorted_temps = sorted(list(all_temps))
        self.db_data_rows = []
        for t in sorted_temps:
            row = {"temp": t}
            for prop_key in self.ALL_KEYS:
                # Используем нашу универсальную функцию, но здесь нам нужны ТОЧНЫЕ значения,
                # а не интерполяция, поэтому логику лучше оставить "сырой" или добавить флаг exact в метод Material
                # Для простоты используем интерполяцию, так как если точка есть, она вернется точно.
                val = material.get_interpolated_property(prop_key, t, category_idx=cat_idx if cat_idx != -1 else None)
                row[prop_key] = val
            self.db_data_rows.append(row)
        self._render_table()

    def _calculate_custom_row(self, temp):
        mat_name = self.material_combo.get()
        material = next((m for m in self.app_data.materials if m.get_display_name() == mat_name), None)
        if not material: return {"temp": temp}
        cat_idx = self.category_combo.current()

        row = {"temp": temp}
        for prop_key in self.ALL_KEYS:
             # ! ВЫЗОВ НОВОГО МЕТОДА !
            val = material.get_interpolated_property(prop_key, temp, category_idx=cat_idx if cat_idx != -1 else None)
            row[prop_key] = val
        return row

    def _render_table(self):
        self.tree.delete(*self.tree.get_children())

        visible_keys = [k for k in self.ALL_KEYS if self.column_visibility[k]]
        cols = ["temp"] + visible_keys
        self.tree["columns"] = cols

        self.tree.heading("temp", text="T, °C")
        self.tree.column("temp", width=70, anchor="center", stretch=False)

        for prop_key in visible_keys:
            if prop_key in PHYSICAL_PROPERTIES_MAP:
                info = PHYSICAL_PROPERTIES_MAP[prop_key]
            else:
                info = MECHANICAL_PROPERTIES_MAP[prop_key]

            base_unit = info.get("unit", "")
            current_unit = self.column_units.get(prop_key)

            if not current_unit:
                unit_type = info.get("unit_type")
                if unit_type:
                    avail = UnitManager.get_units(unit_type)
                    current_unit = base_unit if base_unit in avail else UnitManager.get_system_unit(unit_type)
                else:
                    current_unit = base_unit
                self.column_units[prop_key] = current_unit

            header_text = f"{info.get('symbol', prop_key)}\n{current_unit}"
            self.tree.heading(prop_key, text=header_text)
            self.tree.column(prop_key, width=90, anchor="center")

        def insert_row(row_dict, tag=""):
            values = [row_dict["temp"]]
            for prop_key in visible_keys:
                raw_val = row_dict.get(prop_key)
                if raw_val is None:
                    values.append("-")
                    continue

                info = PHYSICAL_PROPERTIES_MAP.get(prop_key) or MECHANICAL_PROPERTIES_MAP.get(prop_key)
                unit_type = info.get("unit_type")
                base_unit = info.get("unit")
                target_unit = self.column_units.get(prop_key)

                if unit_type and base_unit and target_unit:
                    try:
                        sys_val = UnitManager.to_system(raw_val, base_unit, unit_type)
                        final_val = UnitManager.from_system(sys_val, target_unit, unit_type)
                        formatted = f"{final_val:.2f}".rstrip('0').rstrip(
                            '.') if final_val % 1 != 0 else f"{int(final_val)}"
                        values.append(formatted)
                    except:
                        values.append(str(raw_val))
                else:
                    values.append(str(raw_val))

            self.tree.insert("", "end", values=values, tags=(tag,))

        # 1. Данные из БД
        for row in self.db_data_rows:
            insert_row(row)

        # 2. Разделитель (если есть кастомные данные)
        if self.custom_temps:
            sep_values = ["РАСЧЕТ"] + [""] * len(visible_keys)
            self.tree.insert("", "end", values=sep_values, tags=("separator",))

            # 3. Пользовательские данные (считаем на лету)
            for t in self.custom_temps:
                calc_row = self._calculate_custom_row(t)
                insert_row(calc_row, tag="custom_calc")

    # --- КАЛЬКУЛЯТОР ---

    def _add_custom_calculation(self):
        temp = safe_float(self.calc_temp_entry.get())
        if temp is None:
            messagebox.showerror("Ошибка", "Некорректная температура")
            return

        self.custom_temps.append(temp)
        self.custom_temps.sort()
        self._render_table()
        self.tree.yview_moveto(1)
        self.calc_temp_entry.delete(0, tk.END)

    def _remove_selected_custom_row(self):
        """Удаляет только выделенную строку, если это расчет."""
        selected_item = self.tree.selection()
        if not selected_item: return

        item = self.tree.item(selected_item[0])
        tags = item.get("tags", [])

        if "custom_calc" in tags:
            try:
                # Первое значение в values - это температура (строка)
                temp_val = float(item["values"][0])

                # Удаляем первое вхождение этой температуры из списка
                if temp_val in self.custom_temps:
                    self.custom_temps.remove(temp_val)
                    self._render_table()
            except (ValueError, IndexError):
                pass
        else:
            messagebox.showinfo("Инфо", "Можно удалять только строки из раздела расчетов.")

    def _clear_custom_rows(self):
        self.custom_temps = []
        self._render_table()

    # --- КОНТЕКСТНОЕ МЕНЮ (ПКМ) ---
    def _on_header_right_click(self, event):
        region = self.tree.identify_region(event.x, event.y)
        if region == "heading":
            col_id = self.tree.identify_column(event.x)
            col_index = int(col_id.replace('#', '')) - 1
            current_cols = self.tree["columns"]

            if 0 <= col_index < len(current_cols):
                prop_key = current_cols[col_index]
                if prop_key == "temp": return
                self._show_unit_menu(event, prop_key)

    def _show_unit_menu(self, event, prop_key):
        if prop_key in PHYSICAL_PROPERTIES_MAP:
            info = PHYSICAL_PROPERTIES_MAP[prop_key]
        else:
            info = MECHANICAL_PROPERTIES_MAP.get(prop_key)

        if not info: return
        unit_type = info.get("unit_type")
        if not unit_type: return

        available = UnitManager.get_units(unit_type)
        current = self.column_units.get(prop_key)

        menu = tk.Menu(self, tearoff=0)
        for u in available:
            menu.add_radiobutton(label=u, value=u,
                                 variable=tk.StringVar(value=current),
                                 command=lambda x=u: self._change_unit(prop_key, x))
        menu.post(event.x_root, event.y_root)

    def _change_unit(self, prop_key, new_unit):
        self.column_units[prop_key] = new_unit
        self._render_table()


class PropertyComparisonTab(ttk.Frame):
    """Вкладка 'Сравнение материалов (свойства)' с новым интерфейсом выбора."""

    def __init__(self, parent, app_data):
        super().__init__(parent)
        self.app_data = app_data
        self.listbox_item_map = {}
        self._setup_widgets()

    def _setup_widgets(self):
        main_frame = ttk.Frame(self)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        controls_frame = ttk.Frame(main_frame, width=300)
        controls_frame.pack(side="left", fill="y", padx=(0, 10))
        controls_frame.pack_propagate(False)

        ttk.Label(controls_frame, text="Область применения:").pack(fill="x", pady=(0, 2))
        self.area_combo = ttk.Combobox(controls_frame, state="readonly")
        self.area_combo.pack(fill="x", pady=(0, 10))
        self.area_combo.bind("<<ComboboxSelected>>", self._update_search_pool)

        ttk.Label(controls_frame, text="Свойство для сравнения:").pack(fill="x", pady=(0, 2))
        prop_names = [f"{info['name']} ({info.get('symbol', '')})" for info in ALL_PROPERTIES_MAP.values()]
        self.prop_keys = list(ALL_PROPERTIES_MAP.keys())
        self.prop_combo = ttk.Combobox(controls_frame, state="readonly", values=prop_names)
        self.prop_combo.pack(fill="x", pady=(0, 10))
        if prop_names:
            self.prop_combo.current(0)
        self.prop_combo.bind("<<ComboboxSelected>>", lambda e: self._plot_graph())

        ttk.Label(controls_frame, text="Поиск материала:").pack(fill="x", pady=(5, 2))
        self.search_entry = ttk.Entry(controls_frame)
        self.search_entry.pack(fill="x", pady=(0, 5))
        self.search_entry.bind("<KeyRelease>", self._filter_search_results)

        search_list_frame = ttk.LabelFrame(controls_frame, text="Результаты поиска")
        search_list_frame.pack(fill="both", expand=True, pady=(0, 10))

        self.search_listbox = tk.Listbox(search_list_frame, exportselection=False)
        search_scrollbar = ttk.Scrollbar(search_list_frame, orient="vertical", command=self.search_listbox.yview)
        self.search_listbox.config(yscrollcommand=search_scrollbar.set)
        search_scrollbar.pack(side="right", fill="y")
        self.search_listbox.pack(side="left", fill="both", expand=True)
        self.search_listbox.bind("<Double-1>", self._add_material_to_selection)

        selected_list_frame = ttk.LabelFrame(controls_frame, text="Выбранные материалы")
        selected_list_frame.pack(fill="both", expand=True, pady=(0, 10))

        self.selected_listbox = tk.Listbox(selected_list_frame, exportselection=False)
        selected_scrollbar = ttk.Scrollbar(selected_list_frame, orient="vertical", command=self.selected_listbox.yview)
        self.selected_listbox.config(yscrollcommand=selected_scrollbar.set)
        selected_scrollbar.pack(side="right", fill="y")
        self.selected_listbox.pack(side="left", fill="both", expand=True)
        self.selected_listbox.bind("<Double-1>", self._remove_material_from_selection)

        plot_button = ttk.Button(controls_frame, text="Построить график", command=self._plot_graph)
        plot_button.pack(fill="x", pady=(0, 5))

        reset_button = ttk.Button(controls_frame, text="Сбросить", command=self._reset_selection)
        reset_button.pack(fill="x")

        self.plot_frame = ttk.Frame(main_frame)
        self.plot_frame.pack(side="right", fill="both", expand=True)
        fig = Figure(figsize=(8, 6), dpi=100)
        self.ax = fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(fig, master=self.plot_frame)
        toolbar = CustomToolbar(self.canvas, self.plot_frame, plot_callback=self._plot_graph)
        toolbar.update()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

    def update_lists(self):
        """Вызывается при загрузке данных. Обновляет фильтры и пулы данных."""
        areas = ["Все"] + self.app_data.application_areas
        self.area_combo.config(values=areas)
        self.area_combo.set("Все")
        self._update_search_pool()

    def _update_search_pool(self, event=None):
        """Обновляет `listbox_item_map`, который является источником для поиска."""
        self.listbox_item_map.clear()
        selected_area = self.area_combo.get()

        for mat in self.app_data.materials:
            if selected_area != "Все" and selected_area not in mat.data.get("metadata", {}, ).get("application_area",
                                                                                                  []):
                continue

            display_name = mat.get_display_name()
            # Добавляем сам материал (для физ. свойств)
            self.listbox_item_map[display_name] = (mat.data, None)

            # Добавляем категории прочности
            for cat in mat.data.get("mechanical_properties", {}).get("strength_category", []):
                cat_name = cat.get('value_strength_category', '')
                display_name_with_cat = f"{display_name} {cat_name}".strip()
                self.listbox_item_map[display_name_with_cat] = (mat.data, cat.copy())

        self._filter_search_results()

    def _filter_search_results(self, event=None):
        """Фильтрует список `search_listbox` на основе текста в `search_entry`."""
        search_term = self.search_entry.get().lower()
        self.search_listbox.delete(0, tk.END)

        sorted_keys = sorted(self.listbox_item_map.keys())

        for name in sorted_keys:
            if search_term in name.lower():
                self.search_listbox.insert(tk.END, name)

    def _add_material_to_selection(self, event):
        """Добавляет материал из списка поиска в список выбранных."""
        selected_indices = self.search_listbox.curselection()
        if not selected_indices: return

        name_to_add = self.search_listbox.get(selected_indices[0])
        current_selected = self.selected_listbox.get(0, tk.END)

        if name_to_add not in current_selected:
            self.selected_listbox.insert(tk.END, name_to_add)

    def _remove_material_from_selection(self, event):
        """Удаляет материал из списка выбранных."""
        selected_indices = self.selected_listbox.curselection()
        if not selected_indices: return

        self.selected_listbox.delete(selected_indices[0])

    def _reset_selection(self):
        """Сбрасывает список выбранных материалов и график."""
        self.selected_listbox.delete(0, tk.END)
        self.search_entry.delete(0, tk.END)
        self._filter_search_results()
        self._plot_graph()

    def _add_minor_gridlines(self):
        # Эта функция остается без изменений
        x_ticks = self.ax.get_xticks()
        if len(x_ticks) > 1:
            for i in range(len(x_ticks) - 1):
                mid_point = (x_ticks[i] + x_ticks[i + 1]) / 2
                self.ax.axvline(x=mid_point, color='grey', linestyle='--', linewidth=0.5, alpha=0.7)
        y_ticks = self.ax.get_yticks()
        if len(y_ticks) > 1:
            for i in range(len(y_ticks) - 1):
                mid_point = (y_ticks[i] + y_ticks[i + 1]) / 2
                self.ax.axhline(y=mid_point, color='grey', linestyle='--', linewidth=0.5, alpha=0.7)

    def _plot_graph(self):
        """Строит график на основе списка `selected_listbox`."""
        prop_idx = self.prop_combo.current()
        if prop_idx == -1:
            messagebox.showwarning("Внимание", "Выберите свойство для отображения.")
            return

        prop_key = self.prop_keys[prop_idx]
        prop_info = ALL_PROPERTIES_MAP.get(prop_key)
        if not prop_info: return

        self.ax.clear()

        selected_names = self.selected_listbox.get(0, tk.END)
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22',
                  '#17becf']

        for i, display_name in enumerate(selected_names):
            color = colors[i % len(colors)]
            material_data, category_data = self.listbox_item_map.get(display_name, (None, None))

            if not material_data: continue

            prop_data = None

            # --- НАЧАЛО ИСПРАВЛЕННОЙ ЛОГИКИ ---
            is_mechanical = prop_key in MECHANICAL_PROPERTIES_MAP

            if is_mechanical:
                # Если свойство механическое, ищем его ТОЛЬКО в категории
                if category_data and prop_key in category_data:
                    prop_data = category_data[prop_key]
            else:
                # Если свойство физическое, ищем его в ОБЩИХ данных материала
                if prop_key in material_data.get("physical_properties", {}):
                    prop_data = material_data["physical_properties"][prop_key]
            # --- КОНЕЦ ИСПРАВЛЕННОЙ ЛОГИКИ ---

            if prop_data and "temperature_value_pairs" in prop_data and prop_data["temperature_value_pairs"]:
                pairs = sorted(prop_data["temperature_value_pairs"], key=lambda p: p[0])
                temps = [p[0] for p in pairs]
                values = [p[1] for p in pairs]
                self.ax.plot(temps, values, marker='o', linestyle='-', label=display_name, color=color)
                for t, v in zip(temps, values):
                    text_label = f"{v:.0f}" if v == int(v) else f"{v:.1f}"
                    self.ax.annotate(text_label, xy=(t, v), xytext=(5, 5), textcoords='offset points', fontsize=8,
                                     color='dimgray')
            else:
                self.ax.plot([], [], marker='o', linestyle='-', label=f"{display_name} (нет данных)", color=color)

        self.ax.set_xlabel("Температура [°С]")
        self.ax.set_ylabel(f"{prop_info['name']} [{prop_info['unit']}]")
        self.ax.set_title(f"Зависимость свойства '{prop_info['name']}' от температуры")

        if selected_names:
            self.ax.legend()

        self.ax.grid(True)
        self._add_minor_gridlines()
        self.canvas.draw()


class ChemComparisonTab(ttk.Frame, ScrollableMixin):
    def __init__(self, parent, app_data):
        super().__init__(parent)
        self.app_data = app_data
        self.element_tooltips = {
            "C": "Углерод.\nПовышает: Твердость, прочность, упругость.\nСнижает: Пластичность, вязкость.",
            "Si": "Кремний.\nПовышает: Прочность, упругость, электросопротивление, жаростойкость, твердость.\nСнижает: -.",
            "P": "Фосфор.\nПовышает: Прочность, коррозионная стойкость.\nСнижает: Пластичность, вязкость",
            "S": "Сера.\nПовышает: Хрупкость при высоких температурах. \nСнижает: Прочность, пластичность, свариваемость, коррозионная стойкость",
            "N2": "Азот.\nПовышает: -. \nСнижает: Вязкость, пластичность.",
            "O2": "Кислород.\nПовышает: -. \nСнижает: Вязкость, пластичность.",
            "H2": "Водород.\nПовышает: Хрупкость. \nСнижает: -.",
            "Cr": "Хром.\nПовышает: Твердость, прочность, ударная вязкость, коррозионная стойкость, электросопротивление. \nСнижает: Коэффициент линейного расширения, пластичность.",
            "Ni": "Никель.\nПовышает: Пластичность, вязкость, коррозионная стойкость, ударная прочность. \nСнижает: -.",
            "W": "Вольфрам.\nПовышает: Твердость, прокаливаемость. \nСнижает: -.",
            "Mo": "Молибден.\nПовышает: Упругость, коррозионная стойкость, сопротивляемость растягивающим нагрузкам, прокаливаемость.  \nСнижает: -.",
            "V": "Ванадий.\nПовышает: Прочность, твердость, плотность. \nСнижает: -.",
            "Mn": "Марганец.\nПовышает: Твердость, износоустойчивость, ударная вязкость, прокаливаемость. \nСнижает: -.",
            "Co": "Кобальт.\nПовышает: Ударная прочность, жаропрочность, магнитные свойства. \nСнижает: -.",
            "Al": "Алюминий.\nПовышает: Жаростойкость, окалиностойкость. \nСнижает: -.",
            "Ti": "Титан.\nПовышает: Прочность, коррозионная стойкость, обрабатываемость. \nСнижает: -.",
            "Nb": "Ниобий.\nПовышает: Коррозионная стойкость, устойчивость к кислотам. \nСнижает: -.",
            "Cu": "Медь.\nПовышает: Коррозионная стойкость, пластичность. \nСнижает: -.",
            "Ce": "Церий.\nПовышает: Пластичность, прочность. \nСнижает: -.",
            "Nd": "Неодим.\nПовышает: Качество поверхности. \nСнижает: Пористость.",
            "Cs": "Цезий.\nПовышает: Качество поверхности. \nСнижает: Пористость.",
            "La": "Лантан.\nПовышает: Качество поверхности. \nСнижает: Пористость.",
            "Sb": "Сурьма.\nПовышает: Отпускную хрупкость. \nСнижает: Качество поверхности литья."
        }
        self.filter_entries = {}
        self.all_composition_data = []
        self.sorted_elements = []
        self._setup_widgets()

    def _setup_widgets(self):
        main_frame = ttk.Frame(self)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        controls_frame = ttk.Frame(main_frame, width=250)
        controls_frame.pack(side="left", fill="y", padx=(0, 10))
        controls_frame.pack_propagate(False)

        ttk.Label(controls_frame, text="Область применения:").pack(fill="x", pady=(0, 2))
        self.area_combo = ttk.Combobox(controls_frame, state="readonly")
        self.area_combo.pack(fill="x", pady=(0, 10))
        self.area_combo.bind("<<ComboboxSelected>>", self._update_material_listbox)

        ttk.Label(controls_frame, text="Поиск материала:").pack(fill="x", pady=(0, 2))
        self.search_entry = ttk.Entry(controls_frame)
        self.search_entry.pack(fill="x", pady=(0, 10))
        self.search_entry.bind("<KeyRelease>", self._update_material_listbox)

        ttk.Label(controls_frame, text="Выберите материалы:").pack(fill="x", pady=(0, 2))
        list_frame = ttk.Frame(controls_frame)
        list_frame.pack(fill="both", expand=True, pady=(0, 10))
        self.mat_listbox = tk.Listbox(list_frame, selectmode=tk.MULTIPLE, exportselection=False)
        list_scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.mat_listbox.yview)
        self.mat_listbox.config(yscrollcommand=list_scrollbar.set)
        list_scrollbar.pack(side="right", fill="y")
        self.mat_listbox.pack(side="left", fill="both", expand=True)
        self.mat_listbox.bind("<<ListboxSelect>>", self._setup_comparison_view)

        results_area_frame = ttk.Frame(main_frame)
        results_area_frame.pack(side="right", fill="both", expand=True)
        self.filter_frame = ttk.LabelFrame(results_area_frame, text="Фильтры по элементам (%)", padding=10)
        self.filter_frame.pack(fill="x", pady=(0, 10))

        scrollable_container = ttk.Frame(results_area_frame)
        scrollable_container.pack(fill="both", expand=True)
        scrollable_container.grid_rowconfigure(0, weight=1)
        scrollable_container.grid_columnconfigure(0, weight=1)
        self.canvas = tk.Canvas(scrollable_container)
        self.canvas.grid(row=0, column=0, sticky="nsew")
        vsb = ttk.Scrollbar(scrollable_container, orient="vertical", command=self.canvas.yview)
        vsb.grid(row=0, column=1, sticky="ns")
        hsb = ttk.Scrollbar(scrollable_container, orient="horizontal", command=self.canvas.xview)
        hsb.grid(row=1, column=0, sticky="ew")
        self.canvas.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        self.results_grid_frame = ttk.Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.results_grid_frame, anchor="nw")
        self.results_grid_frame.bind("<Configure>",
                                     lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))

        # --- MIXIN SCROLL ---
        self.bind_mouse_wheel(self.canvas)
        self.bind_mouse_wheel(self.results_grid_frame, self.canvas)

    def _reset_element_filters(self):
        for entry in self.filter_entries.values(): entry.delete(0, tk.END)
        self._apply_filters_and_resort()

    def update_lists(self):
        self.area_combo.config(values=["Все"] + getattr(self.app_data, 'application_areas', []))
        self.area_combo.set("Все")
        self.search_entry.delete(0, tk.END)
        self._update_material_listbox()

    def _update_material_listbox(self, event=None):
        self.mat_listbox.delete(0, tk.END)
        selected_area = self.area_combo.get()
        search_term = self.search_entry.get().lower()

        for mat in self.app_data.materials:
            if not mat.data.get("chemical_properties", {}).get("composition"): continue
            if selected_area != "Все" and selected_area not in mat.data.get("metadata", {}).get("application_area",
                                                                                                []): continue
            display_name = mat.get_display_name()
            if search_term and search_term not in display_name.lower(): continue
            self.mat_listbox.insert(tk.END, display_name)

        if selected_area != "Все" and not search_term:
            self.mat_listbox.selection_set(0, tk.END)
        self._setup_comparison_view()

    def _setup_comparison_view(self, event=None):
        saved_filter_values = {elem: entry.get() for elem, entry in self.filter_entries.items() if entry.get()}
        for widget in self.filter_frame.winfo_children(): widget.destroy()
        for widget in self.results_grid_frame.winfo_children(): widget.destroy()
        self.filter_entries.clear()
        self.all_composition_data.clear()

        selected_indices = self.mat_listbox.curselection()
        selected_names = {self.mat_listbox.get(i) for i in selected_indices}
        selected_mats = [m for m in self.app_data.materials if m.get_display_name() in selected_names]

        if not selected_mats: return

        all_elements = set()
        for mat in selected_mats:
            for comp in mat.data.get("chemical_properties", {}).get("composition", []):

                # --- ГИБРИДНАЯ ЛОГИКА ИСТОЧНИКА ---
                source_name = "-"
                ref_id = comp.get("source_ref_id")
                if ref_id and self.app_data.source_manager:
                    source_name = self.app_data.source_manager.get_name_by_id(ref_id)
                else:
                    source_name = comp.get("composition_source", "")

                if comp.get("composition_subsource"):
                    source_name += f" ({comp.get('composition_subsource')})"

                elements_map = {elem['element']: elem for elem in comp.get("other_elements", [])}
                self.all_composition_data.append({
                    "material_name": mat.get_display_name(),
                    "source": source_name,
                    "base_element": comp.get("base_element", "-"),
                    "elements_map": elements_map
                })
                all_elements.update(elements_map.keys())

        if not all_elements: return
        self.sorted_elements = sorted(list(all_elements))

        col = 0
        for elem in self.sorted_elements:
            frame = ttk.Frame(self.filter_frame)
            frame.grid(row=0, column=col, padx=5, pady=2, sticky='w')
            ttk.Label(frame, text=elem).pack(side="left")
            entry = ttk.Entry(frame, width=6)
            entry.pack(side="left", padx=(2, 0))
            entry.bind("<KeyRelease>", self._apply_filters_and_resort)
            self.filter_entries[elem] = entry
            if elem in saved_filter_values: entry.insert(0, saved_filter_values[elem])
            col += 1

        reset_button = ttk.Button(self.filter_frame, text="Сбросить", command=self._reset_element_filters)
        reset_button.grid(row=1, column=0, columnspan=col or 1, pady=(10, 0), sticky='w')
        self._apply_filters_and_resort()

    def _format_chem_value(self, elem_data):
        if not elem_data: return "-"
        min_v, max_v = elem_data.get("min_value"), elem_data.get("max_value")
        min_tol = elem_data.get("min_value_tolerance")
        max_tol = elem_data.get("max_value_tolerance")
        if min_v == 0: min_v = None
        if max_v == 0: max_v = None
        if min_v is not None and max_v is not None:
            min_tol_str = f"({min_tol}) " if min_tol not in (None, '') else ""
            max_tol_str = f" ({max_tol})" if max_tol not in (None, '') else ""
            return f"{min_tol_str}{min_v} - {max_v}{max_tol_str}"
        elif max_v is not None:
            max_tol_str = f" ({max_tol})" if max_tol not in (None, '') else ""
            return f"≤ {max_v}{max_tol_str}"
        elif min_v is not None:
            min_tol_str = f" ({min_tol})" if min_tol not in (None, '') else ""
            return f"≥ {min_v}{min_tol_str}"
        else:
            return "-"

    def _apply_filters_and_resort(self, event=None):
        targets = {}
        for elem, entry in self.filter_entries.items():
            val_str = entry.get().strip()
            if val_str:
                # safe_float уже обрабатывает ошибки и возвращает None, если не число
                # но нам нужно None только если строка пустая
                val = safe_float(val_str)
                if val is not None:
                    targets[elem] = val

        processed_data = []
        for comp_data in self.all_composition_data:
            score, cell_colors, is_fully_matching = 0, {}, True
            for elem, target_val in targets.items():
                if target_val is None: continue
                elem_info = comp_data["elements_map"].get(elem)
                if not elem_info:
                    is_fully_matching = False
                    cell_colors[elem] = "light coral"
                    continue
                min_v, max_v = elem_info.get("min_value"), elem_info.get("max_value")

                lower_bound = float('-inf') if min_v is None else min_v
                upper_bound = float('inf') if max_v is None else max_v

                if lower_bound <= target_val <= upper_bound:
                    score += 1
                    cell_colors[elem] = "pale green"
                else:
                    is_fully_matching = False
                    cell_colors[elem] = "light coral"
            comp_data['is_match'], comp_data['score'], comp_data[
                'cell_colors'] = is_fully_matching, score if is_fully_matching else -1, cell_colors
            processed_data.append(comp_data)
        processed_data.sort(key=lambda x: (x.get('is_match', False), x.get('score', 0)), reverse=True)
        self._populate_results_grid(processed_data)

    def _populate_results_grid(self, data_to_show):
        for widget in self.results_grid_frame.winfo_children(): widget.destroy()
        headers = ["Материал", "Источник", "Основа"] + self.sorted_elements
        header_widths = [150, 200, 60] + [100] * len(self.sorted_elements)
        for col, text in enumerate(headers):
            self.results_grid_frame.columnconfigure(col, minsize=header_widths[col])
            label = ttk.Label(self.results_grid_frame, text=text, font=("TkDefaultFont", 9, "bold"), anchor="center",
                              relief="groove", padding=5)
            label.grid(row=0, column=col, sticky="nsew")
            if text in self.element_tooltips: Tooltip(label, self.element_tooltips[text])

        for row, comp_data in enumerate(data_to_show, start=1):
            row_bg_color = "honeydew" if comp_data.get('is_match', True) else "misty rose"

            def bind_scroll(w):
                # Используем метод из Mixin
                self.bind_mouse_wheel(w, self.canvas)

            l1 = tk.Label(self.results_grid_frame, text=comp_data["material_name"], relief="groove", padx=5, pady=5,
                          background=row_bg_color)
            l1.grid(row=row, column=0, sticky="nsew");
            bind_scroll(l1)

            l2 = tk.Label(self.results_grid_frame, text=comp_data["source"], relief="groove", padx=5, pady=5,
                          background=row_bg_color)
            l2.grid(row=row, column=1, sticky="nsew");
            bind_scroll(l2)

            l3 = tk.Label(self.results_grid_frame, text=comp_data["base_element"], anchor="center", relief="groove",
                          padx=5, pady=5, background=row_bg_color)
            l3.grid(row=row, column=2, sticky="nsew");
            bind_scroll(l3)

            for col, elem_name in enumerate(self.sorted_elements, start=3):
                elem_info = comp_data["elements_map"].get(elem_name)
                text_val = self._format_chem_value(elem_info)
                cell_bg_color = comp_data.get("cell_colors", {}).get(elem_name, row_bg_color)
                cell = tk.Label(self.results_grid_frame, text=text_val, background=cell_bg_color, relief="groove",
                                padx=5, pady=5)
                cell.grid(row=row, column=col, sticky="nsew");
                bind_scroll(cell)


class AshbyDiagramTab(ttk.Frame):
    """Вкладка для построения гибких диаграмм Эшби с новым интерфейсом выбора."""

    def __init__(self, parent, app_data):
        super().__init__(parent)
        self.app_data = app_data
        self.listbox_item_map = {}

        self.ashby_properties_map = {
            "temperature": {"name": "Температура", "symbol": "T", "unit": "°С"},
            **ALL_PROPERTIES_MAP
        }
        self.ashby_prop_keys = list(self.ashby_properties_map.keys())
        self.ashby_prop_names = [f"{info['name']} ({info.get('symbol', '')})" for info in
                                 self.ashby_properties_map.values()]

        self._setup_widgets()

    def _setup_widgets(self):
        main_frame = ttk.Frame(self)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        controls_frame = ttk.Frame(main_frame, width=300)
        controls_frame.pack(side="left", fill="y", padx=(0, 10))
        controls_frame.pack_propagate(False)

        ttk.Label(controls_frame, text="Область применения:").pack(fill="x", pady=(0, 2))
        self.area_combo = ttk.Combobox(controls_frame, state="readonly")
        self.area_combo.pack(fill="x", pady=(0, 10))
        self.area_combo.bind("<<ComboboxSelected>>", self._update_search_pool)

        ttk.Label(controls_frame, text="Ось X:").pack(fill="x", pady=(5, 2))
        self.x_axis_combo = ttk.Combobox(controls_frame, state="readonly", values=self.ashby_prop_names)
        self.x_axis_combo.pack(fill="x", pady=(0, 5))
        self.x_axis_combo.bind("<<ComboboxSelected>>", self._on_axis_change)

        ttk.Label(controls_frame, text="Ось Y:").pack(fill="x", pady=(5, 2))
        self.y_axis_combo = ttk.Combobox(controls_frame, state="readonly", values=self.ashby_prop_names)
        self.y_axis_combo.pack(fill="x", pady=(0, 10))
        self.y_axis_combo.bind("<<ComboboxSelected>>", self._on_axis_change)

        ttk.Label(controls_frame, text="Поиск материала:").pack(fill="x", pady=(5, 2))
        self.search_entry = ttk.Entry(controls_frame)
        self.search_entry.pack(fill="x", pady=(0, 5))
        self.search_entry.bind("<KeyRelease>", self._filter_search_results)

        search_list_frame = ttk.LabelFrame(controls_frame, text="Результаты поиска")
        search_list_frame.pack(fill="both", expand=True, pady=(0, 10))
        self.search_listbox = tk.Listbox(search_list_frame, exportselection=False)
        search_scrollbar = ttk.Scrollbar(search_list_frame, orient="vertical", command=self.search_listbox.yview)
        self.search_listbox.config(yscrollcommand=search_scrollbar.set)
        search_scrollbar.pack(side="right", fill="y")
        self.search_listbox.pack(side="left", fill="both", expand=True)
        self.search_listbox.bind("<Double-1>", self._add_material_to_selection)

        selected_list_frame = ttk.LabelFrame(controls_frame, text="Выбранные материалы")
        selected_list_frame.pack(fill="both", expand=True, pady=(0, 10))
        self.selected_listbox = tk.Listbox(selected_list_frame, exportselection=False)
        selected_scrollbar = ttk.Scrollbar(selected_list_frame, orient="vertical", command=self.selected_listbox.yview)
        self.selected_listbox.config(yscrollcommand=selected_scrollbar.set)
        selected_scrollbar.pack(side="right", fill="y")
        self.selected_listbox.pack(side="left", fill="both", expand=True)
        self.selected_listbox.bind("<Double-1>", self._remove_material_from_selection)

        plot_button = ttk.Button(controls_frame, text="Построить диаграмму", command=self._plot_diagram)
        plot_button.pack(fill="x", pady=(0, 5))

        reset_button = ttk.Button(controls_frame, text="Сбросить", command=self._reset_selection)
        reset_button.pack(fill="x")

        self.plot_frame = ttk.Frame(main_frame)
        self.plot_frame.pack(side="right", fill="both", expand=True)
        fig = Figure(figsize=(8, 6), dpi=100)
        self.ax = fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(fig, master=self.plot_frame)
        toolbar = NavigationToolbar2Tk(self.canvas, self.plot_frame)
        toolbar.update()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        self.x_axis_combo.set("Предел текучести (σ_0,2)")
        self.y_axis_combo.set("Температура (T)")
        self._on_axis_change()

    def update_lists(self):
        areas = ["Все"] + self.app_data.application_areas
        self.area_combo.config(values=areas)
        self.area_combo.set("Все")
        self._update_search_pool()

    def _update_search_pool(self, event=None):
        self.listbox_item_map.clear()
        selected_area = self.area_combo.get()
        for mat in self.app_data.materials:
            if selected_area != "Все" and selected_area not in mat.data.get("metadata", {}).get("application_area", []):
                continue
            display_name = mat.get_display_name()
            self.listbox_item_map[display_name] = (mat.data, None)
            for cat in mat.data.get("mechanical_properties", {}).get("strength_category", []):
                cat_name = cat.get('value_strength_category', '')
                display_name_with_cat = f"{display_name} {cat_name}".strip()
                self.listbox_item_map[display_name_with_cat] = (mat.data, cat.copy())
        self._filter_search_results()

    def _filter_search_results(self, event=None):
        search_term = self.search_entry.get().lower()
        self.search_listbox.delete(0, tk.END)
        for name in sorted(self.listbox_item_map.keys()):
            if search_term in name.lower():
                self.search_listbox.insert(tk.END, name)

    def _add_material_to_selection(self, event):
        selected_indices = self.search_listbox.curselection()
        if not selected_indices: return
        name_to_add = self.search_listbox.get(selected_indices[0])
        if name_to_add not in self.selected_listbox.get(0, tk.END):
            self.selected_listbox.insert(tk.END, name_to_add)

    def _remove_material_from_selection(self, event):
        selected_indices = self.selected_listbox.curselection()
        if not selected_indices: return
        self.selected_listbox.delete(selected_indices[0])

    def _reset_selection(self):
        self.selected_listbox.delete(0, tk.END)
        self._plot_diagram()

    def _on_axis_change(self, event=None):
        x_selection = self.x_axis_combo.get()
        y_selection = self.y_axis_combo.get()
        if x_selection:
            self.y_axis_combo['values'] = [name for name in self.ashby_prop_names if name != x_selection]
        if y_selection:
            self.x_axis_combo['values'] = [name for name in self.ashby_prop_names if name != y_selection]
        if x_selection: self.x_axis_combo.set(x_selection)
        if y_selection: self.y_axis_combo.set(y_selection)
        self._plot_diagram()

    def _plot_diagram(self):
        x_selection_text = self.x_axis_combo.get()
        y_selection_text = self.y_axis_combo.get()
        if not x_selection_text or not y_selection_text: return

        x_prop_key = self.ashby_prop_keys[self.ashby_prop_names.index(x_selection_text)]
        y_prop_key = self.ashby_prop_keys[self.ashby_prop_names.index(y_selection_text)]
        x_prop_info = self.ashby_properties_map[x_prop_key]
        y_prop_info = self.ashby_properties_map[y_prop_key]

        self.ax.clear()
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22',
                  '#17becf']
        selected_display_names = self.selected_listbox.get(0, tk.END)

        for i, display_name in enumerate(selected_display_names):
            color = colors[i % len(colors)]
            material_data, category_data = self.listbox_item_map.get(display_name, (None, None))

            if not material_data: continue

            # --- НАЧАЛО ИСПРАВЛЕННОЙ ЛОГИКИ ---
            def get_axis_values(axis_prop_key, material_data, category_data):
                """Универсальная функция для получения значений для любой оси."""

                # Определяем, какое свойство является источником температурных точек.
                # Если на другой оси температура, то источником будет текущее свойство.
                # Если на другой оси тоже свойство, то каждое свойство - источник само для себя.
                other_axis_prop_key = x_prop_key if axis_prop_key == y_prop_key else y_prop_key
                source_prop_key = axis_prop_key if axis_prop_key != 'temperature' else other_axis_prop_key

                is_source_mechanical = source_prop_key in MECHANICAL_PROPERTIES_MAP

                prop_data_source = None
                if is_source_mechanical:
                    # Ищем источник данных в категории
                    if category_data and source_prop_key in category_data:
                        prop_data_source = category_data[source_prop_key]
                else:
                    # Ищем источник данных в физ.свойствах
                    if source_prop_key in material_data.get("physical_properties", {}):
                        prop_data_source = material_data["physical_properties"][source_prop_key]

                # Если источник данных для температур не найден, выходим
                if not prop_data_source or "temperature_value_pairs" not in prop_data_source or not prop_data_source[
                    "temperature_value_pairs"]:
                    return None

                # Теперь получаем значения для самой оси
                if axis_prop_key == 'temperature':
                    return [p[0] for p in prop_data_source["temperature_value_pairs"]]
                else:
                    is_axis_mechanical = axis_prop_key in MECHANICAL_PROPERTIES_MAP
                    prop_data_axis = None
                    if is_axis_mechanical:
                        if category_data and axis_prop_key in category_data:
                            prop_data_axis = category_data[axis_prop_key]
                    else:
                        if axis_prop_key in material_data.get("physical_properties", {}):
                            prop_data_axis = material_data["physical_properties"][axis_prop_key]

                    if prop_data_axis and "temperature_value_pairs" in prop_data_axis and prop_data_axis[
                        "temperature_value_pairs"]:
                        return [p[1] for p in prop_data_axis["temperature_value_pairs"]]

                return None

            x_values = get_axis_values(x_prop_key, material_data, category_data)
            y_values = get_axis_values(y_prop_key, material_data, category_data)

            if x_values and y_values:
                # Данные есть, строим эллипс
                min_x, max_x = min(x_values), max(x_values)
                min_y, max_y = min(y_values), max(y_values)
                width, height = max_x - min_x, max_y - min_y
                center_x, center_y = min_x + width / 2, min_y + height / 2

                ellipse = Ellipse(xy=(center_x, center_y),
                                  width=width if width > 0 else 0.1,
                                  height=height if height > 0 else 0.1,
                                  angle=0, facecolor=color, alpha=0.4, label=display_name)
                self.ax.add_patch(ellipse)
                self.ax.text(center_x, center_y, display_name, ha='center', va='center', fontsize=8,
                             bbox=dict(boxstyle='round,pad=0.2', fc='white', ec='none', alpha=0.6))
            else:
                # Данных нет, добавляем "пустышку" в легенду
                self.ax.plot([], [], marker='o', linestyle='-', label=f"{display_name} (нет данных)", color=color)
            # --- КОНЕЦ ИСПРАВЛЕННОЙ ЛОГИКИ ---

        self.ax.set_xlabel(f"{x_prop_info['name']} [{x_prop_info['unit']}]")
        self.ax.set_ylabel(f"{y_prop_info['name']} [{y_prop_info['unit']}]")
        self.ax.set_title(f"Диаграмма Эшби: {y_prop_info['name']} vs. {x_prop_info['name']}")

        if selected_display_names:
            self.ax.legend(fontsize='small')

        self.ax.grid(True, linestyle='--', alpha=0.7)
        if self.ax.patches:
            self.ax.autoscale_view()
        self.canvas.draw()


# ======================================================================================
# БЛОК 6: ВКЛАДКИ РЕДАКТОРА
# ======================================================================================


class SinglePropertyEditor(ttk.Frame):
    """
    Переиспользуемый компонент для редактирования одного свойства.
    Содержит: Поля (Unit, Subsource, Comment), Таблицу точек и График.
    """

    def __init__(self, parent, prop_key, prop_info):
        super().__init__(parent)
        self.prop_key = prop_key
        self.prop_info = prop_info

        # Данные графика
        self.fig = None
        self.ax = None
        self.canvas = None

        self._setup_layout()

    def _setup_layout(self):
        # Разделение на левую (поля) и правую (график) части
        content_frame = ttk.Frame(self)
        content_frame.pack(fill="both", expand=True)

        left_panel = ttk.Frame(content_frame)
        left_panel.pack(side="left", fill="both", expand=True, padx=(0, 10))

        right_panel = ttk.Frame(content_frame)
        right_panel.pack(side="right", fill="both", expand=True)

        # --- ЛЕВАЯ ПАНЕЛЬ (ПОЛЯ ВЕРТИКАЛЬНО) ---
        left_panel.columnconfigure(1, weight=1)

        # 1. Единица измерения
        ttk.Label(left_panel, text="Ед. изм:").grid(row=0, column=0, sticky="w", pady=2)

        unit_type = self.prop_info.get("unit_type")
        units = UnitManager.get_units(unit_type) if unit_type else [self.prop_info["unit"]]

        self.unit_combo = ttk.Combobox(left_panel, values=units, state="readonly", width=15)
        self.unit_combo.grid(row=0, column=1, sticky="we", pady=2)
        if self.prop_info["unit"] in units:
            self.unit_combo.set(self.prop_info["unit"])

        # При смене единицы обновляем график
        self.unit_combo.bind("<<ComboboxSelected>>", lambda e: self.update_graph())

        # 2. Под-источник
        ttk.Label(left_panel, text="Под-источник:").grid(row=1, column=0, sticky="w", pady=2)
        self.subsource_entry = ttk.Entry(left_panel)
        self.subsource_entry.grid(row=1, column=1, sticky="we", pady=2)

        # 3. Комментарий
        ttk.Label(left_panel, text="Комментарий:").grid(row=2, column=0, sticky="w", pady=2)
        self.comment_entry = ttk.Entry(left_panel)
        self.comment_entry.grid(row=2, column=1, sticky="we", pady=2)

        # 4. Таблица
        table_frame = ttk.Frame(left_panel)
        table_frame.grid(row=3, column=0, columnspan=2, sticky="nsew", pady=5)
        left_panel.rowconfigure(3, weight=1)

        self.tree = create_editable_treeview(table_frame, on_update_callback=self.update_graph)

        self.tree.configure(show="headings")
        self.tree["columns"] = ("temp", "value")

        self.tree.heading("temp", text="T, °C")
        self.tree.column("temp", width=130, anchor="center")

        self.tree.heading("value", text="Значение")
        self.tree.column("value", width=130, anchor="center")

        self.tree.pack(side="left", fill="both", expand=True)

        # Кнопки +/-
        btn_frame = ttk.Frame(table_frame)
        btn_frame.pack(side="left", fill="y", padx=5)
        ttk.Button(btn_frame, text="+", width=2,
                   command=lambda: (self.tree.insert("", "end", values=["0", "0"]), self.update_graph())).pack(pady=2)
        ttk.Button(btn_frame, text="-", width=2,
                   command=lambda: (self.tree.delete(self.tree.selection()), self.update_graph())).pack(pady=2)

        # --- ПРАВАЯ ПАНЕЛЬ (ГРАФИК) ---
        self.fig = Figure(figsize=(4, 3), dpi=90)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=right_panel)
        self.canvas.get_tk_widget().pack(fill="both", expand=True)

    def update_graph(self):
        """Перерисовывает график на основе данных из таблицы."""
        points = []
        for item in self.tree.get_children():
            v = self.tree.set(item)
            # Safe float для защиты от запятых
            t_val = safe_float(v["temp"])
            v_val = safe_float(v["value"])
            if t_val is not None and v_val is not None:
                points.append((t_val, v_val))

        points.sort(key=lambda p: p[0])

        self.ax.clear()
        if points:
            ts, vs = zip(*points)
            self.ax.plot(ts, vs, 'o-', markersize=4)

        unit = self.unit_combo.get()
        self.ax.set_ylabel(unit, fontsize=8)
        self.ax.set_xlabel("T, °C", fontsize=8)
        self.ax.grid(True, linestyle='--', alpha=0.6)
        self.ax.tick_params(labelsize=8)
        self.fig.tight_layout()
        self.canvas.draw()

    def set_data(self, prop_data):
        """Заполняет поля данными из словаря."""
        unit = prop_data.get("value_unit") or prop_data.get("property_unit")
        if unit and unit in self.unit_combo['values']:
            self.unit_combo.set(unit)
        else:
            self.unit_combo.set(self.prop_info["unit"])

        self.subsource_entry.delete(0, tk.END)
        self.subsource_entry.insert(0, prop_data.get("property_subsource", ""))
        self.comment_entry.delete(0, tk.END)
        self.comment_entry.insert(0, prop_data.get("comment", ""))

        for i in self.tree.get_children(): self.tree.delete(i)
        for t, v in prop_data.get("temperature_value_pairs", []):
            self.tree.insert("", "end", values=[t, v])

        self.update_graph()

    def get_data(self):
        """Собирает данные из полей."""
        pairs = []
        for item in self.tree.get_children():
            v = self.tree.set(item)
            t_val = safe_float(v["temp"])
            v_val = safe_float(v["value"])
            if t_val is not None and v_val is not None:
                pairs.append([t_val, v_val])

        has_meta = self.subsource_entry.get() or self.comment_entry.get()

        if pairs or has_meta:
            return {
                "temperature_value_pairs": pairs,
                "value_unit": self.unit_combo.get(),
                "property_subsource": self.subsource_entry.get(),
                "comment": self.comment_entry.get()
            }
        return None


class GeneralDataTab(ttk.Frame, ScrollableMixin):
    def __init__(self, parent, app_data):
        super().__init__(parent, padding=10)
        self.app_data = app_data
        self.area_widgets = {}
        self._setup_widgets()

    def _setup_widgets(self):
        self.columnconfigure(1, weight=1)

        # Основные поля
        ttk.Label(self, text="Наименование (стандарт):").grid(row=0, column=0, sticky="w", pady=2)
        self.name_entry = ttk.Entry(self, width=60)
        self.name_entry.grid(row=0, column=1, sticky="we", pady=2)
        ttk.Label(self, text="Альтернативные названия\n(через запятую):").grid(row=1, column=0, sticky="nw", pady=2)
        self.alt_names_entry = ttk.Entry(self, width=60)
        self.alt_names_entry.grid(row=1, column=1, sticky="we", pady=2)
        ttk.Label(self, text="Общий комментарий:").grid(row=2, column=0, sticky="nw", pady=2)
        self.comment_entry = ttk.Entry(self, width=60)
        self.comment_entry.grid(row=2, column=1, sticky="we", pady=2)

        # Классификация
        class_frame = ttk.LabelFrame(self, text="Классификация", padding=5)
        class_frame.grid(row=3, column=0, columnspan=2, sticky="we", pady=10)
        class_frame.columnconfigure(1, weight=1)
        ttk.Label(class_frame, text="Категория:").grid(row=0, column=0, sticky="w")
        self.cat_entry = ttk.Entry(class_frame)
        self.cat_entry.grid(row=0, column=1, sticky="we", padx=5)
        ttk.Label(class_frame, text="Класс:").grid(row=1, column=0, sticky="w")
        self.class_entry = ttk.Entry(class_frame)
        self.class_entry.grid(row=1, column=1, sticky="we", padx=5)
        ttk.Label(class_frame, text="Подкласс:").grid(row=2, column=0, sticky="w")
        self.subclass_entry = ttk.Entry(class_frame)
        self.subclass_entry.grid(row=2, column=1, sticky="we", padx=5)

        # Области применения (Scroll)
        area_frame = ttk.LabelFrame(self, text="Области применения", padding=5)
        area_frame.grid(row=4, column=0, columnspan=2, sticky="nsew", pady=10)
        self.rowconfigure(4, weight=1)
        checkbox_canvas = tk.Canvas(area_frame, borderwidth=0, highlightthickness=0)
        scrollbar = ttk.Scrollbar(area_frame, orient="vertical", command=checkbox_canvas.yview)
        self.checkbox_container = ttk.Frame(checkbox_canvas)
        self.checkbox_container.bind("<Configure>",
                                     lambda e: checkbox_canvas.configure(scrollregion=checkbox_canvas.bbox("all")))
        checkbox_canvas.create_window((0, 0), window=self.checkbox_container, anchor="nw")
        checkbox_canvas.configure(yscrollcommand=scrollbar.set)

        # Биндим скролл через Mixin
        self.bind_mouse_wheel(checkbox_canvas)
        self.bind_mouse_wheel(self.checkbox_container, checkbox_canvas)

        checkbox_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Добавление области
        add_area_frame = ttk.Frame(self)
        add_area_frame.grid(row=5, column=0, columnspan=2, sticky="we", pady=(0, 10))
        add_label = ttk.Label(add_area_frame, text="Добавить область применения:")
        add_label.pack(side="left", padx=(0, 5))
        add_button = ttk.Button(add_area_frame, text="Добавить", command=self._add_new_area)
        add_button.pack(side="right")
        self.new_area_entry = ttk.Entry(add_area_frame)
        self.new_area_entry.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Параметры применения
        temp_app_frame = ttk.LabelFrame(self, text="Параметры применения", padding=5)
        temp_app_frame.grid(row=6, column=0, columnspan=2, sticky="we", pady=10)
        temp_app_frame.columnconfigure(1, weight=1)
        ttk.Label(temp_app_frame, text="Температура применения ДО, °С:").grid(row=0, column=0, sticky="w", padx=5,
                                                                              pady=2)
        self.temp_app_value_entry = ttk.Entry(temp_app_frame)
        self.temp_app_value_entry.grid(row=0, column=1, sticky="we", padx=5, pady=2)
        ttk.Label(temp_app_frame, text="Комментарий к температуре:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.temp_app_comment_entry = ttk.Entry(temp_app_frame)
        self.temp_app_comment_entry.grid(row=1, column=1, sticky="we", padx=5, pady=2)

    def _add_new_area(self):
        new_area = self.new_area_entry.get().strip()
        if not new_area: return
        if new_area in self.area_widgets:
            messagebox.showinfo("Информация", f"Область '{new_area}' уже есть в списке.", parent=self)
            return
        var = tk.BooleanVar(value=True)
        cb = ttk.Checkbutton(self.checkbox_container, text=new_area, variable=var)
        cb.pack(anchor="w", padx=5, pady=1)

        # Биндим скролл к новому чекбоксу
        self.bind_mouse_wheel(cb, self.checkbox_container.master)  # master is canvas

        self.area_widgets[new_area] = (cb, var)
        self.new_area_entry.delete(0, tk.END)

    def populate_form(self, material):
        meta = material.data.get("metadata", {})
        self.name_entry.delete(0, tk.END)
        self.name_entry.insert(0, meta.get("name_material_standard", ""))
        alt_names_list = meta.get("name_material_alternative", [])
        self.alt_names_entry.delete(0, tk.END)
        self.alt_names_entry.insert(0, ", ".join(alt_names_list))
        self.comment_entry.delete(0, tk.END)
        self.comment_entry.insert(0, meta.get("comment", ""))
        cls = meta.get("classification", {})
        self.cat_entry.delete(0, tk.END)
        self.cat_entry.insert(0, cls.get("classification_category", ""))
        self.class_entry.delete(0, tk.END)
        self.class_entry.insert(0, cls.get("classification_class", ""))
        self.subclass_entry.delete(0, tk.END)
        self.subclass_entry.insert(0, cls.get("classification_subclass", ""))
        for widget, var in self.area_widgets.values():
            widget.destroy()
        self.area_widgets.clear()
        all_known_areas = set()
        for mat_from_db in self.app_data.materials:
            areas = mat_from_db.data.get("metadata", {}).get("application_area", [])
            all_known_areas.update(areas)
        current_material_areas = set(meta.get("application_area", []))
        all_known_areas.update(current_material_areas)
        sorted_areas = sorted(list(all_known_areas))

        canvas_widget = self.checkbox_container.master

        for area in sorted_areas:
            var = tk.BooleanVar()
            if area in current_material_areas:
                var.set(True)
            cb = ttk.Checkbutton(self.checkbox_container, text=area, variable=var)
            cb.pack(anchor="w", padx=5, pady=1)
            self.bind_mouse_wheel(cb, canvas_widget)
            self.area_widgets[area] = (cb, var)

        temp_app_data = meta.get("temperature_application", {})
        self.temp_app_value_entry.delete(0, tk.END)
        self.temp_app_value_entry.insert(0, temp_app_data.get("value", ""))
        self.temp_app_comment_entry.delete(0, tk.END)
        self.temp_app_comment_entry.insert(0, temp_app_data.get("comment", ""))

    def collect_data(self, material):
        meta = material.data["metadata"]
        meta["name_material_standard"] = self.name_entry.get()
        alt_names_str = self.alt_names_entry.get()
        meta["name_material_alternative"] = [name.strip() for name in alt_names_str.split(',') if name.strip()]
        meta["comment"] = self.comment_entry.get().strip()
        cls = meta["classification"]
        cls["classification_category"] = self.cat_entry.get()
        cls["classification_class"] = self.class_entry.get()
        cls["classification_subclass"] = self.subclass_entry.get()
        selected_areas = [area_name for area_name, (widget, var) in self.area_widgets.items() if var.get()]
        meta["application_area"] = selected_areas

        temp_val_str = self.temp_app_value_entry.get().strip()
        temp_comment_str = self.temp_app_comment_entry.get().strip()

        # ИСПОЛЬЗУЕМ safe_float
        temp_val = safe_float(temp_val_str)

        if temp_val is not None or temp_comment_str:
            temp_app_data = meta.setdefault("temperature_application", {})
            temp_app_data["value"] = temp_val
            temp_app_data["comment"] = temp_comment_str
        elif "temperature_application" in meta:
            del meta["temperature_application"]


class PropertyEditorTab(ttk.Frame, ScrollableMixin):
    """Вкладка редактора физических свойств (Refactored)."""

    def __init__(self, parent, prop_group_key, prop_map):
        super().__init__(parent)
        self.prop_group_key = prop_group_key
        self.prop_map = prop_map
        self.editors = {}  # prop_key -> SinglePropertyEditor instance
        self.app_data = None
        self.source_map = {}

        self._setup_widgets()

    def set_app_data(self, app_data):
        self.app_data = app_data
        self._update_source_list()

    def _update_source_list(self):
        if not self.app_data or not self.app_data.source_manager: return
        sources = self.app_data.source_manager.get_all()
        self.source_map = {s["name_source"]: s["id_source"] for s in sources}
        self.source_combo['values'] = sorted(self.source_map.keys())

    def _setup_widgets(self):
        # 1. Верхняя панель
        top_frame = ttk.Frame(self)
        top_frame.pack(fill="x", padx=10, pady=10)
        ttk.Label(top_frame, text="Источник физ. свойств:").pack(side="left", padx=(0, 5))
        self.source_combo = ttk.Combobox(top_frame, state="readonly", width=50)
        self.source_combo.pack(side="left", fill="x", expand=True)

        # 2. Скролл область
        canvas = tk.Canvas(self)
        scrollbar = ttk.Scrollbar(self, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

        window_id = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        def on_canvas_configure(event):
            canvas.itemconfig(window_id, width=event.width)

        canvas.bind("<Configure>", on_canvas_configure)

        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # 3. Создаем редакторы
        for prop_key, prop_info in self.prop_map.items():
            frame = ttk.LabelFrame(scrollable_frame, text=f"{prop_info['name']} ({prop_info['symbol']})", padding=10)
            frame.pack(fill="x", expand=True, padx=10, pady=5)

            editor = SinglePropertyEditor(frame, prop_key, prop_info)
            editor.pack(fill="both", expand=True)
            self.editors[prop_key] = editor

        # --- МАГИЯ: ПРИВЯЗЫВАЕМ ВСЕХ ДЕТЕЙ К СКРОЛЛУ ---
        # Делаем это в конце, когда все виджеты созданы
        # Используем after_idle, чтобы убедиться, что всё отрисовалось
        self.after_idle(lambda: self.bind_all_children(scrollable_frame, canvas))

    def populate_form(self, material):
        self._update_source_list()
        prop_group = material.data.get(self.prop_group_key, {})

        # Источник
        ref_id = prop_group.get("source_ref_id")
        if ref_id and self.app_data:
            name = self.app_data.source_manager.get_name_by_id(ref_id)
            self.source_combo.set(name)
        else:
            self.source_combo.set("")

        # Свойства
        for prop_key, editor in self.editors.items():
            p_data = prop_group.get(prop_key, {})
            editor.set_data(p_data)

    def collect_data(self, material):
        if self.prop_group_key not in material.data:
            material.data[self.prop_group_key] = {}
        prop_group = material.data[self.prop_group_key]

        # Источник
        src_name = self.source_combo.get()
        if src_name and self.app_data:
            sid = self.source_map.get(src_name)
            if sid: prop_group["source_ref_id"] = sid

        # Свойства
        for prop_key, editor in self.editors.items():
            data = editor.get_data()
            if data:
                prop_group[prop_key] = data
                if "property_source" in prop_group[prop_key]:
                    del prop_group[prop_key]["property_source"]
            elif prop_key in prop_group:
                del prop_group[prop_key]


class MechanicalPropertiesTab(ttk.Frame, ScrollableMixin):
    """Вкладка редактора механических свойств (Refactored)."""

    def __init__(self, parent):
        super().__init__(parent, padding=10)
        self.material = None
        self.current_category_idx = -1
        self.editors = {}  # prop_key -> SinglePropertyEditor
        self.app_data = None
        self.source_map = {}
        self._setup_widgets()

    def set_app_data(self, app_data):
        self.app_data = app_data
        self._update_source_list()

    def _update_source_list(self):
        if not self.app_data or not self.app_data.source_manager: return
        sources = self.app_data.source_manager.get_all()
        self.source_map = {s["name_source"]: s["id_source"] for s in sources}
        self.category_source_combo['values'] = sorted(self.source_map.keys())

    def _setup_widgets(self):
        # 1. Панель Категории
        top_frame = ttk.Frame(self)
        top_frame.pack(fill="x", pady=(0, 10))
        ttk.Label(top_frame, text="Категория прочности:").pack(side="left", padx=(0, 5))
        self.category_combo = ttk.Combobox(top_frame, state="readonly", width=40)
        self.category_combo.pack(side="left", fill="x", expand=True)
        self.category_combo.bind("<<ComboboxSelected>>", self._on_category_select)
        ttk.Button(top_frame, text="+", width=3, command=self._add_category).pack(side="left", padx=5)
        ttk.Button(top_frame, text="-", width=3, command=self._delete_category).pack(side="left")

        # 2. Контент редактора
        self.editor_content_frame = ttk.Frame(self)

        cat_meta_frame = ttk.Frame(self.editor_content_frame)
        cat_meta_frame.pack(fill="x", pady=5)
        ttk.Label(cat_meta_frame, text="Название КП:").grid(row=0, column=0, sticky="w", padx=5)
        self.category_name_entry = ttk.Entry(cat_meta_frame, width=20)
        self.category_name_entry.grid(row=0, column=1, sticky="w", padx=5)

        ttk.Label(cat_meta_frame, text="Источник КП:").grid(row=0, column=2, sticky="w", padx=15)
        self.category_source_combo = ttk.Combobox(cat_meta_frame, state="readonly", width=40)
        self.category_source_combo.grid(row=0, column=3, sticky="we", padx=5)
        cat_meta_frame.columnconfigure(3, weight=1)

        # Скролл
        prop_canvas = tk.Canvas(self.editor_content_frame)
        scrollbar = ttk.Scrollbar(self.editor_content_frame, orient="vertical", command=prop_canvas.yview)
        scrollable_frame = ttk.Frame(prop_canvas)

        scrollable_frame.bind("<Configure>", lambda e: prop_canvas.configure(scrollregion=prop_canvas.bbox("all")))

        window_id = prop_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        def on_canvas_configure(event):
            prop_canvas.itemconfig(window_id, width=event.width)

        prop_canvas.bind("<Configure>", on_canvas_configure)

        prop_canvas.configure(yscrollcommand=scrollbar.set)

        prop_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Свойства
        for prop_key, prop_info in MECHANICAL_PROPERTIES_MAP.items():
            frame = ttk.LabelFrame(scrollable_frame, text=f"{prop_info['name']} ({prop_info['symbol']})", padding=10)
            frame.pack(fill="x", expand=True, padx=10, pady=5)

            editor = SinglePropertyEditor(frame, prop_key, prop_info)
            editor.pack(fill="both", expand=True)
            self.editors[prop_key] = editor

        # Твердость
        h_frame = ttk.LabelFrame(scrollable_frame, text="Твердость", padding=10)
        h_frame.pack(fill="x", expand=True, padx=10, pady=5)
        self.hardness_tree = self._create_hardness_table(h_frame)

        # --- ПРИВЯЗКА ВСЕХ ДЕТЕЙ ---
        # Вызываем для scrollable_frame, чтобы прокручивался prop_canvas
        self.after_idle(lambda: self.bind_all_children(scrollable_frame, prop_canvas))

    def _create_hardness_table(self, parent):
        top_h_frame = ttk.Frame(parent)
        top_h_frame.pack(fill="x", pady=(0, 5))

        ttk.Label(top_h_frame, text="Ед. изм:").pack(side="left")
        units = UnitManager.get_units("Твердость")
        self.hardness_unit_combo = ttk.Combobox(top_h_frame, values=units, state="readonly", width=10)
        self.hardness_unit_combo.pack(side="left", padx=5)
        self.hardness_unit_combo.set("HB")

        t_frame = ttk.Frame(parent)
        t_frame.pack(fill="both", expand=True)
        tree = create_editable_treeview(t_frame)
        tree.configure(show="headings")
        tree["columns"] = ("subsource", "min", "max")
        tree.heading("subsource", text="Под-источник");
        tree.column("subsource", width=300)
        tree.heading("min", text="Min");
        tree.column("min", width=60, anchor="center")
        tree.heading("max", text="Max");
        tree.column("max", width=60, anchor="center")
        tree.pack(side="left", fill="both", expand=True)

        b_frame = ttk.Frame(t_frame)
        b_frame.pack(side="left", fill="y", padx=5)
        ttk.Button(b_frame, text="+", width=2, command=lambda: tree.insert("", "end", values=["", "", ""])).pack(pady=2)
        ttk.Button(b_frame, text="-", width=2, command=lambda: tree.delete(tree.selection())).pack(pady=2)
        return tree

    def populate_form(self, material):
        if self.material and self.material != material: self._save_current_category()
        self.material = material
        self.current_category_idx = -1
        self._update_source_list()

        cats = material.data.get("mechanical_properties", {}).get("strength_category", [])
        names = [c.get("value_strength_category", f"КП {i + 1}") for i, c in enumerate(cats)]
        self.category_combo["values"] = names

        if cats:
            self.editor_content_frame.pack(fill="both", expand=True)
            self.category_combo.current(0)
            self._on_category_select()
        else:
            self.category_combo.set("")
            self.editor_content_frame.pack_forget()

    def _on_category_select(self, event=None):
        new_idx = self.category_combo.current()
        if new_idx == -1: return
        if self.current_category_idx != -1 and self.current_category_idx != new_idx:
            self._save_current_category()
        self.current_category_idx = new_idx

        cat_data = self.material.data["mechanical_properties"]["strength_category"][self.current_category_idx]

        self.category_name_entry.delete(0, tk.END)
        self.category_name_entry.insert(0, cat_data.get("value_strength_category", ""))

        ref_id = cat_data.get("source_ref_id")
        if ref_id and self.app_data:
            name = self.app_data.source_manager.get_name_by_id(ref_id)
            self.category_source_combo.set(name)
        else:
            self.category_source_combo.set("")

        for prop_key, editor in self.editors.items():
            p_data = cat_data.get(prop_key, {})
            editor.set_data(p_data)

        # Hardness Unit
        h_unit = cat_data.get("hardness_unit")
        if not h_unit:
            hardness_list = cat_data.get("hardness", [])
            if hardness_list: h_unit = hardness_list[0].get("unit_value")

        if h_unit and h_unit in self.hardness_unit_combo['values']:
            self.hardness_unit_combo.set(h_unit)
        else:
            self.hardness_unit_combo.set("HB")

        tree = self.hardness_tree
        for i in tree.get_children(): tree.delete(i)
        for h in cat_data.get("hardness", []):
            tree.insert("", "end",
                        values=[h.get("property_subsource", ""), h.get("min_value", ""), h.get("max_value", "")])

    def _add_category(self):
        if not self.material: return
        self._save_current_category()
        new_name = f"Новая КП {len(self.category_combo['values']) + 1}"
        new_cat = {"value_strength_category": new_name, "hardness": []}

        if "mechanical_properties" not in self.material.data:
            self.material.data["mechanical_properties"] = {"strength_category": []}

        self.material.data["mechanical_properties"]["strength_category"].append(new_cat)

        vals = list(self.category_combo['values'])
        vals.append(new_name)
        self.category_combo['values'] = vals
        self.category_combo.current(len(vals) - 1)
        self._on_category_select()

    def _delete_category(self):
        if not self.material or self.current_category_idx == -1: return
        if messagebox.askyesno("Подтверждение", "Удалить категорию?"):
            del self.material.data["mechanical_properties"]["strength_category"][self.current_category_idx]
            self.current_category_idx = -1
            self.populate_form(self.material)

    def _save_current_category(self):
        if not self.material or self.current_category_idx == -1: return
        try:
            cat_data = self.material.data["mechanical_properties"]["strength_category"][self.current_category_idx]
        except:
            return

        cat_data["value_strength_category"] = self.category_name_entry.get()
        src_name = self.category_source_combo.get()
        if src_name and self.app_data:
            sid = self.source_map.get(src_name)
            if sid: cat_data["source_ref_id"] = sid

        for prop_key, editor in self.editors.items():
            data = editor.get_data()
            if data:
                cat_data[prop_key] = data
                if "property_source" in cat_data[prop_key]: del cat_data[prop_key]["property_source"]
            elif prop_key in cat_data:
                del cat_data[prop_key]

        current_h_unit = self.hardness_unit_combo.get()
        cat_data["hardness_unit"] = current_h_unit

        h_list = []
        for item in self.hardness_tree.get_children():
            v = self.hardness_tree.set(item)
            h = {
                "property_subsource": v["subsource"],
                "unit_value": current_h_unit,
                "min_value": None,
                "max_value": None
            }
            # SAFE FLOAT
            h["min_value"] = safe_float(v["min"])
            h["max_value"] = safe_float(v["max"])

            if h["property_subsource"] or h["min_value"] is not None:
                h_list.append(h)
        cat_data["hardness"] = h_list

        vals = list(self.category_combo['values'])
        vals[self.current_category_idx] = cat_data["value_strength_category"]
        self.category_combo['values'] = vals

    def collect_data(self, material):
        if self.material == material: self._save_current_category()


class ChemicalCompositionTab(ttk.Frame):
    """Вкладка для редактирования химического состава с логарифмической гистограммой."""

    # Словарь элементов
    ELEMENTS_MAP = {
        "Ag": {"name": "Серебро", "color": "#C0C0C0"},
        "Al": {"name": "Алюминий", "color": "#B5B5B5"},
        "As": {"name": "Мышьяк", "color": "#7D8080"},
        "B":  {"name": "Бор", "color": "#2B2B2B"},
        "Be": {"name": "Бериллий", "color": "#B8CC7A"},
        "Bi": {"name": "Висмут", "color": "#C885C4"},
        "C":  {"name": "Углерод", "color": "#363636"},
        "Ca": {"name": "Кальций", "color": "#808080"},
        "Cd": {"name": "Кадмий", "color": "#D1C366"},
        "Ce": {"name": "Церий", "color": "#FFFFC7"},
        "Cl": {"name": "Хлор", "color": "#1FF22D"},
        "Co": {"name": "Кобальт", "color": "#1A569E"},
        "Cr": {"name": "Хром", "color": "#8A9EA8"},
        "Cu": {"name": "Медь", "color": "#D98048"},
        "Fe": {"name": "Железо", "color": "#8C3E26"},
        "H":  {"name": "Водород", "color": "#F0F0F0"},
        "La": {"name": "Лантан", "color": "#8AFAFA"},
        "Li": {"name": "Литий", "color": "#B52FED"},
        "Mg": {"name": "Магний", "color": "#E3E3E3"},
        "Mn": {"name": "Марганец", "color": "#8C6A8A"},
        "Mo": {"name": "Молибден", "color": "#8F88A1"},
        "N":  {"name": "Азот", "color": "#6B85F0"},
        "Na": {"name": "Натрий", "color": "#F2F20C"},
        "Nb": {"name": "Ниобий", "color": "#6ED6C6"},
        "Nd": {"name": "Неодим", "color": "#C7FACF"},
        "Ni": {"name": "Никель", "color": "#5C8F54"},
        "O":  {"name": "Кислород", "color": "#E60E0E"},
        "P":  {"name": "Фосфор", "color": "#DE5914"},
        "Pb": {"name": "Свинец", "color": "#525252"},
        "S":  {"name": "Сера", "color": "#F2E82E"},
        "Sb": {"name": "Сурьма", "color": "#A1759C"},
        "Si": {"name": "Кремний", "color": "#8C8C8C"},
        "Sn": {"name": "Олово", "color": "#858282"},
        "Ti": {"name": "Титан", "color": "#85878A"},
        "V":  {"name": "Ванадий", "color": "#949494"},
        "W":  {"name": "Вольфрам", "color": "#5C5857"},
        "Y":  {"name": "Иттрий", "color": "#8AFAFA"},
        "Zn": {"name": "Цинк", "color": "#797D82"},
        "Zr": {"name": "Цирконий", "color": "#C4E0B6"},
        "РЗМ": {"name": "РЗМ", "color": "#E0E0E0"},
        "Au": {"name": "Золото", "color": "#FFD700"},
        "Ba": {"name": "Барий", "color": "#00C900"},
        "F":  {"name": "Фтор", "color": "#DAA520"},
        "Ga": {"name": "Галлий", "color": "#C2C2C2"},
        "Hg": {"name": "Ртуть", "color": "#E6E6E6"},
        "In": {"name": "Индий", "color": "#4B0082"},
        "Ir": {"name": "Иридий", "color": "#FFDEAD"},
        "Pd": {"name": "Палладий", "color": "#006400"},
        "Pt": {"name": "Платина", "color": "#E5E4E2"},
        "Rh": {"name": "Родий", "color": "#FF00FF"},
        "Se": {"name": "Селен", "color": "#A0522D"},
        "Ta": {"name": "Тантал", "color": "#4682B4"},
        "Te": {"name": "Теллур", "color": "#D2691E"},
        "Tl": {"name": "Таллий", "color": "#A52A2A"},
        "Ru": {"name": "Рутений", "color": "#708090"}
    }

    def __init__(self, parent):
        super().__init__(parent, padding=10)
        self.material = None
        self.current_source_idx = -1
        self.app_data = None
        self.element_menu = None

        # Переменные для чекбоксов графика
        self.var_min = tk.BooleanVar(value=False)
        self.var_max = tk.BooleanVar(value=True)

        # График
        self.fig = None
        self.ax = None
        self.canvas = None

        self._setup_widgets()

    def set_app_data(self, app_data):
        self.app_data = app_data

    def _setup_widgets(self):
        # --- Верхняя панель ---
        top_frame = ttk.Frame(self)
        top_frame.pack(fill="x", pady=(0, 10))
        ttk.Label(top_frame, text="Источник состава:").pack(side="left", padx=(0, 5))
        self.source_combo = ttk.Combobox(top_frame, state="readonly", width=40)
        self.source_combo.pack(side="left", fill="x", expand=True)
        self.source_combo.bind("<<ComboboxSelected>>", self._on_source_select)
        ttk.Button(top_frame, text="+", width=3, command=self._add_source).pack(side="left", padx=5)
        ttk.Button(top_frame, text="-", width=3, command=self._delete_source).pack(side="left")

        # --- Основной контейнер редактора ---
        self.editor_content_frame = ttk.Frame(self)
        self.editor_content_frame.pack(fill="both", expand=True)
        self.editor_content_frame.pack_forget()

        # 1. Метаданные
        meta_frame = ttk.LabelFrame(self.editor_content_frame, text="Данные источника", padding=5)
        meta_frame.pack(fill="x", pady=5)
        meta_frame.columnconfigure(1, weight=1)

        ttk.Label(meta_frame, text="Источник:").grid(row=0, column=0, sticky="w")
        self.source_entry = ttk.Entry(meta_frame)
        self.source_entry.grid(row=0, column=1, sticky="we", padx=5, pady=2)

        ttk.Label(meta_frame, text="Под-источник:").grid(row=1, column=0, sticky="w")
        self.subsource_entry = ttk.Entry(meta_frame)
        self.subsource_entry.grid(row=1, column=1, sticky="we", padx=5, pady=2)

        ttk.Label(meta_frame, text="Комментарий:").grid(row=2, column=0, sticky="w")
        self.comment_entry = ttk.Entry(meta_frame)
        self.comment_entry.grid(row=2, column=1, sticky="we", padx=5, pady=2)

        ttk.Label(meta_frame, text="Основной элемент:").grid(row=3, column=0, sticky="w")
        self.base_element_entry = ttk.Combobox(meta_frame, values=["Fe", "Ti"], width=10)
        self.base_element_entry.grid(row=3, column=1, sticky="w", padx=5, pady=2)
        self.base_element_entry.bind("<<ComboboxSelected>>", lambda e: self._update_chart())
        self.base_element_entry.bind("<KeyRelease>", lambda e: self._update_chart())

        ttk.Label(meta_frame, text="Ед. изм.:").grid(row=4, column=0, sticky="w")
        units = UnitManager.get_units("Безразмерный")
        self.unit_combo = ttk.Combobox(meta_frame, values=units, state="readonly", width=10)
        self.unit_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)
        self.unit_combo.set("%")

        # 2. Разделенный контейнер
        split_container = ttk.Frame(self.editor_content_frame)
        split_container.pack(fill="both", expand=True, pady=5)

        # -- Левая часть: Таблица --
        left_pane = ttk.Frame(split_container)
        left_pane.pack(side="left", fill="both", expand=True, padx=(0, 5))

        elements_frame = ttk.LabelFrame(left_pane, text="Элементы (ПКМ по названию для выбора)", padding=5)
        elements_frame.pack(fill="both", expand=True)
        self.elements_tree = self._create_elements_table(elements_frame)

        # -- Правая часть: График --
        right_pane = ttk.Frame(split_container)
        right_pane.pack(side="right", fill="both", expand=True, padx=(5, 0))
        self._create_chart_panel(right_pane)

        # Меню ПКМ
        self.element_menu = tk.Menu(self, tearoff=0)
        sorted_items = sorted(self.ELEMENTS_MAP.items(), key=lambda x: x[1]["name"])
        for symbol, data in sorted_items:
            # data теперь словарь, берем имя из него
            name = data["name"]
            label_text = f"{name} ({symbol})"
            self.element_menu.add_command(label=label_text,
                                          command=lambda s=symbol, n=name: self._fill_element_from_menu(s, n))

    def _create_elements_table(self, parent_frame):
        table_frame = ttk.Frame(parent_frame)
        table_frame.pack(fill="both", expand=True)
        table_frame.columnconfigure(0, weight=1)

        tree = create_editable_treeview(table_frame, on_update_callback=self._update_chart)
        tree.configure(show="headings")
        tree["columns"] = ("name", "elem", "min", "max", "min_tol", "max_tol")

        tree.heading("name", text="Название элемента")
        tree.column("name", width=120)
        tree.heading("elem", text="Элемент")
        tree.column("elem", width=60, anchor="center")
        tree.heading("min", text="Min")
        tree.column("min", width=60, anchor="center")
        tree.heading("max", text="Max")
        tree.column("max", width=60, anchor="center")
        tree.heading("min_tol", text="Допуск Min")
        tree.column("min_tol", width=80, anchor="center")
        tree.heading("max_tol", text="Допуск Max")
        tree.column("max_tol", width=80, anchor="center")

        tree.pack(side="left", fill="both", expand=True)

        btn_frame = ttk.Frame(table_frame)
        btn_frame.pack(side="left", fill="y", padx=5)

        def add_row():
            tree.insert("", "end", values=["", "", "", "", "", ""])
            self._update_chart()

        def del_row():
            sel = tree.selection()
            if sel:
                tree.delete(sel)
                self._update_chart()

        ttk.Button(btn_frame, text="+", width=2, command=add_row).pack(pady=2)
        ttk.Button(btn_frame, text="-", width=2, command=del_row).pack(pady=2)

        tree.bind("<Button-3>", self._on_tree_right_click)
        return tree

    def _create_chart_panel(self, parent):
        """Создает панель с графиком и переключателями."""

        # 1. Верхний контейнер для ГРАФИКА
        # Используем weight=1, чтобы график занимал всё свободное место
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        plot_frame = ttk.LabelFrame(parent, text="Распределение элементов в составе")
        plot_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        self.fig = Figure(figsize=(5, 4), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.fig.subplots_adjust(left=0.2, right=0.95, top=0.9, bottom=0.15)

        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_frame)
        self.canvas.get_tk_widget().pack(fill="both", expand=True)

        # 2. Нижний контейнер для ЧЕКБОКСОВ
        # row=1, не растягивается по вертикали (weight=0 по умолчанию)
        ctrl_frame = ttk.Frame(parent)
        ctrl_frame.grid(row=1, column=0, sticky="ew", padx=5, pady=5)

        # Логика переключения
        def toggle_min():
            if self.var_min.get():
                self.var_max.set(False)
            elif not self.var_max.get():
                self.var_max.set(True)
            self._update_chart()

        def toggle_max():
            if self.var_max.get():
                self.var_min.set(False)
            elif not self.var_min.get():
                self.var_min.set(True)
            self._update_chart()

        # Чекбоксы
        cb_min = ttk.Checkbutton(ctrl_frame, text="Min", variable=self.var_min, command=toggle_min)
        cb_min.pack(side="left", padx=10)

        cb_max = ttk.Checkbutton(ctrl_frame, text="Max", variable=self.var_max, command=toggle_max)
        cb_max.pack(side="left", padx=10)

    def _update_chart(self):
        """
        Перестраивает график: горизонтальные бары с логарифмической шкалой.
        Только Min или Max значения.
        """
        if not self.ax or not self.canvas: return

        self.ax.clear()

        # Данные для построения: список словарей {label, value, color}
        plot_data = []

        base_elem_sym = self.base_element_entry.get().strip()
        if not base_elem_sym: base_elem_sym = "Основа"
        base_elem_name = self.ELEMENTS_MAP.get(base_elem_sym, {}).get("name", "Основа")
        base_elem_color = self.ELEMENTS_MAP.get(base_elem_sym, {}).get("color", "#444444")

        use_max = self.var_max.get()
        # Если не Max, значит Min

        total_elements_amount = 0.0

        for item_id in self.elements_tree.get_children():
            row = self.elements_tree.item(item_id, "values")
            # row: name, elem, min, max, min_tol, max_tol
            elem_sym = row[1]
            if not elem_sym: continue

            # Получаем цвет
            color = self.ELEMENTS_MAP.get(elem_sym, {}).get("color", "#1f77b4")

            val_min = safe_float(row[2])
            val_max = safe_float(row[3])

            value = 0.0

            if use_max:
                # Режим MAX
                if val_max is not None: value = val_max
            else:
                # Режим MIN
                if val_min is not None: value = val_min

            if value > 0:
                plot_data.append({
                    "label": elem_sym,
                    "value": value,
                    "color": color
                })
                total_elements_amount += value

        # Рассчитываем основу (100% - сумма элементов)
        base_percent = 100.0 - total_elements_amount
        if base_percent < 0: base_percent = 0

        # Добавляем основу
        plot_data.append({
            "label": base_elem_sym,
            "value": base_percent,
            "color": base_elem_color
        })

        if not plot_data:
            self.ax.text(0.5, 0.5, "Нет данных", ha='center', va='center')
        else:
            # Сортировка: Сначала большие значения (Основа), потом мелкие
            plot_data.sort(key=lambda x: x["value"], reverse=False)

            labels = [d["label"] for d in plot_data]
            values = [d["value"] for d in plot_data]
            colors = [d["color"] for d in plot_data]

            # Рисуем бары
            bars = self.ax.barh(labels, values, color=colors)

            # ЛОГАРИФМИЧЕСКАЯ ШКАЛА
            self.ax.set_xscale('log')
            self.ax.grid(True, axis='x', which="both", ls="--", alpha=0.4)

            unit = self.unit_combo.get()

            # Подписи значений
            for i, val in enumerate(values):
                # Форматирование текста
                text_val = f"{val:.4f}".rstrip('0').rstrip('.') if val < 0.1 else f"{val:.2f}"
                txt = f" {text_val} {unit}"

                self.ax.text(val, i, txt, va='center', ha='left', fontsize=8, fontweight='bold')

            self.ax.set_xlabel(f"Содержание ({unit})")

            # Пределы X
            # Максимум на графике (обычно это Основа ~100 или меньше)
            max_val_graph = max(values) if values else 100

            # Минимум (не ноль для логарифма)
            non_zero_vals = [v for v in values if v > 0]
            min_val_graph = min(non_zero_vals) if non_zero_vals else 0.001

            # Ставим пределы с запасом справа для текста
            self.ax.set_xlim(min_val_graph * 0.5, max_val_graph * 5)

        self.fig.tight_layout()
        self.canvas.draw()

    def populate_form(self, material):
        if self.material and self.material != material:
            self._save_current_source()

        self.material = material
        self.current_source_idx = -1

        compositions = material.data.get("chemical_properties", {}).get("composition", [])
        self.source_combo["values"] = [comp.get("composition_source", f"Источник {i + 1}") for i, comp in
                                       enumerate(compositions)]

        if compositions:
            self.source_combo.current(0)
            self._on_source_select()
        else:
            self.source_combo.set("")
            self.editor_content_frame.pack_forget()

    def _on_source_select(self, event=None):
        self._save_current_source()

        idx = self.source_combo.current()
        if idx == -1:
            self.editor_content_frame.pack_forget()
            return

        self.current_source_idx = idx
        comp_data = self.material.data["chemical_properties"]["composition"][idx]
        self._populate_source_fields(comp_data)
        self.editor_content_frame.pack(fill="both", expand=True)

    def _populate_source_fields(self, comp_data):
        """Заполняет поля редактирования из данных (Обновлено для новой структуры ELEMENTS_MAP)."""
        self.source_entry.delete(0, tk.END)
        self.source_entry.insert(0, comp_data.get("composition_source", ""))
        self.subsource_entry.delete(0, tk.END)
        self.subsource_entry.insert(0, comp_data.get("composition_subsource", ""))
        self.comment_entry.delete(0, tk.END)
        self.comment_entry.insert(0, comp_data.get("comment", ""))

        self.base_element_entry.set(comp_data.get("base_element", ""))

        first_elem = comp_data.get("other_elements", [{}])[0] if comp_data.get("other_elements") else {}
        unit = first_elem.get("unit_value", "%")
        self.unit_combo.set(unit)

        for i in self.elements_tree.get_children(): self.elements_tree.delete(i)

        for elem in comp_data.get("other_elements", []):
            symbol = elem.get("element", "")
            # ИЗМЕНЕНИЕ: Получаем имя из словаря словарей
            name = self.ELEMENTS_MAP.get(symbol, {}).get("name", "")

            self.elements_tree.insert("", "end", values=[
                name,
                symbol,
                elem.get("min_value", ""),
                elem.get("max_value", ""),
                elem.get("min_value_tolerance", ""),
                elem.get("max_value_tolerance", "")
            ])

        self._update_chart()

    def _add_source(self):
        if not self.material: return
        self._save_current_source()
        new_source = {"composition_source": "Новый источник", "other_elements": []}
        compositions = self.material.data["chemical_properties"]["composition"]
        compositions.append(new_source)
        self.populate_form(self.material)
        self.source_combo.current(len(compositions) - 1)
        self._on_source_select()

    def _delete_source(self):
        if not self.material or self.current_source_idx == -1: return
        if messagebox.askyesno("Подтверждение", "Вы уверены, что хотите удалить этот источник хим. состава?"):
            compositions = self.material.data["chemical_properties"]["composition"]
            del compositions[self.current_source_idx]
            self.source_combo.set("")
            self.populate_form(self.material)

    def _save_current_source(self):
        if not self.material or self.current_source_idx == -1: return
        try:
            comp_data = self.material.data["chemical_properties"]["composition"][self.current_source_idx]
        except IndexError:
            return

        comp_data["composition_source"] = self.source_entry.get()
        comp_data["composition_subsource"] = self.subsource_entry.get()
        comp_data["comment"] = self.comment_entry.get()
        comp_data["base_element"] = self.base_element_entry.get()

        common_unit = self.unit_combo.get()

        elements_list = []
        for item_id in self.elements_tree.get_children():
            values = self.elements_tree.set(item_id)
            if not values.get("elem"): continue

            elem_data = {
                "element": values["elem"],
                "unit_value": common_unit
            }

            elem_data["min_value"] = safe_float(values["min"])
            elem_data["max_value"] = safe_float(values["max"])

            if values["min_tol"]: elem_data["min_value_tolerance"] = values["min_tol"]
            if values["max_tol"]: elem_data["max_value_tolerance"] = values["max_tol"]

            elements_list.append(elem_data)
        comp_data["other_elements"] = elements_list
        self._update_chart()

    def collect_data(self, material):
        self._save_current_source()
        self.material = material

    def _on_tree_right_click(self, event):
        region = self.elements_tree.identify_region(event.x, event.y)
        if region == "cell":
            item = self.elements_tree.identify_row(event.y)
            column = self.elements_tree.identify_column(event.x)
            if column in ("#1", "#2"):
                self.elements_tree.selection_set(item)
                self.elements_tree.focus(item)
                self.element_menu.post(event.x_root, event.y_root)

    def _fill_element_from_menu(self, symbol, name):
        """Обновлено для новой структуры map."""
        selected_item = self.elements_tree.selection()
        if not selected_item: return

        item_id = selected_item[0]
        current_values = list(self.elements_tree.item(item_id, "values"))

        current_values[0] = name
        current_values[1] = symbol

        self.elements_tree.item(item_id, values=current_values)
        self._update_chart()


class EditorFrame(ttk.Frame):
    def __init__(self, parent, app_data, main_app):
        super().__init__(parent)
        self.app_data = app_data
        self.main_app = main_app  # <--- ВОТ ЭТА СТРОКА ВАЖНА
        self.editing_copy = None
        self._setup_widgets()

        # Передаем данные во вкладки для работы с источниками
        self.phys_tab.set_app_data(app_data)
        self.mech_tab.set_app_data(app_data)
        self.chem_tab.set_app_data(app_data)

        # Изначально кнопки выключены
        self._update_button_states(False)

        self._update_button_states(False)

    def _setup_widgets(self):
        # --- Верхняя панель управления ---
        top_frame = ttk.Frame(self)
        top_frame.pack(fill="x", padx=10, pady=10)

        ttk.Label(top_frame, text="Выберите материал:").pack(side="left")
        self.mat_combo = ttk.Combobox(top_frame, state="readonly", width=40)
        self.mat_combo.pack(side="left", padx=5)
        self.mat_combo.bind("<<ComboboxSelected>>", self.load_material)

        new_button = ttk.Button(top_frame, text="Создать новый", command=self.create_new_material)
        new_button.pack(side="left", padx=(10, 5))

        # --- НАЧАЛО ИЗМЕНЕНИЙ: Новые кнопки ---
        self.save_button = ttk.Button(top_frame, text="Сохранить", command=self.save_material)
        self.save_button.pack(side="left", padx=5)

        self.save_as_button = ttk.Button(top_frame, text="Сохранить как...", command=self.save_material_as)
        self.save_as_button.pack(side="left", padx=5)

        self.revert_button = ttk.Button(top_frame, text="Отменить изменения", command=self.revert_changes)
        self.revert_button.pack(side="left", padx=5)
        # --- КОНЕЦ ИЗМЕНЕНИЙ ---

        # --- Notebook для вкладок редактора ---
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill="both", padx=10, pady=(0, 10))

        self.general_tab = GeneralDataTab(self.notebook, self.app_data)
        self.phys_tab = PropertyEditorTab(self.notebook, "physical_properties", PHYSICAL_PROPERTIES_MAP)
        self.mech_tab = MechanicalPropertiesTab(self.notebook)
        self.chem_tab = ChemicalCompositionTab(self.notebook)

        self.notebook.add(self.general_tab, text="Общие данные", state="disabled")
        self.notebook.add(self.phys_tab, text="Физические свойства", state="disabled")
        self.notebook.add(self.mech_tab, text="Механические свойства", state="disabled")
        self.notebook.add(self.chem_tab, text="Химический состав", state="disabled")

    # --- НОВЫЙ МЕТОД: Управление состоянием кнопок ---
    def _update_button_states(self, active=False):
        state = "normal" if active else "disabled"
        self.save_button.config(state=state)
        self.save_as_button.config(state=state)
        self.revert_button.config(state=state)

    def update_view(self):
        mat_names = [m.get_display_name() for m in self.app_data.materials]
        self.mat_combo.config(values=mat_names)

        if self.editing_copy and self.editing_copy.get_display_name() in mat_names:
            self.mat_combo.set(self.editing_copy.get_display_name())
        else:
            self.editing_copy = None
            self.app_data.current_material = None
            self.mat_combo.set("")
            self._set_tabs_state("disabled")
            self._update_button_states(False)  # Выключаем кнопки

    def load_material(self, event=None):
        selected_name = self.mat_combo.get()
        material = next((m for m in self.app_data.materials if m.get_display_name() == selected_name), None)
        if material:
            self.app_data.current_material = material
            self.editing_copy = copy.deepcopy(material)
            self._populate_all_tabs()
            self._set_tabs_state("normal")
            self._update_button_states(True)  # Включаем кнопки
            # --- НОВОЕ ИЗМЕНЕНИЕ ---
            self.notebook.select(0) # Выбираем первую вкладку ("Общие данные")

    def create_new_material(self):
        self.editing_copy = Material()
        self.app_data.current_material = None
        self.mat_combo.set(self.editing_copy.filename)
        self._populate_all_tabs()
        self._set_tabs_state("normal")
        self._update_button_states(True)  # Включаем кнопки
        # --- НОВОЕ ИЗМЕНЕНИЕ ---
        self.notebook.select(0) # Выбираем первую вкладку ("Общие данные")

    # --- ПЕРЕМЕЩЕННЫЕ И АДАПТИРОВАННЫЕ МЕТОДЫ ---
    def save_material(self):
        if not self.editing_copy: return
        self.collect_data()
        material_to_save = self.editing_copy

        original_material = self.app_data.current_material
        if original_material:
            changes = find_changes(original_material.data, material_to_save.data)
            log_changes(material_to_save.get_display_name(), changes)

        if not material_to_save.filepath:
            self.save_material_as()
        else:
            try:
                material_to_save.save()
                messagebox.showinfo("Успех", f"Материал '{material_to_save.get_display_name()}' сохранен.")
                # Вызываем перезагрузку данных через главный класс
                self.main_app.open_directory(self.app_data.work_dir, show_success_message=False)
            except Exception as e:
                messagebox.showerror("Ошибка сохранения", f"Не удалось сохранить файл: {e}")

    def save_material_as(self):
        if not self.editing_copy: return
        self.collect_data()
        material_to_save = self.editing_copy

        original_material = self.app_data.current_material
        if original_material:
            changes = find_changes(original_material.data, material_to_save.data)
            log_changes(f"{material_to_save.get_display_name()} (сохранен из {original_material.get_display_name()})",
                        changes)
        else:
            empty_material_data = Material.get_empty_structure()
            changes = find_changes(empty_material_data, material_to_save.data)
            log_changes(material_to_save.get_display_name(), ["Создан новый материал со следующими данными:"] + changes)

        initial_name = material_to_save.get_name().replace(" ", "_") + ".json"
        new_filepath = filedialog.asksaveasfilename(
            initialdir=self.app_data.work_dir, initialfile=initial_name, title="Сохранить материал как...",
            defaultextension=".json", filetypes=[("JSON files", "*.json")])

        if new_filepath:
            try:
                # Обновляем рабочую директорию в app_data через main_app
                self.main_app.app_data.work_dir = os.path.dirname(new_filepath)
                material_to_save.save(filepath=new_filepath)
                messagebox.showinfo("Успех", f"Материал сохранен как '{os.path.basename(new_filepath)}'.")
                # Вызываем перезагрузку данных через главный класс
                self.main_app.open_directory(self.app_data.work_dir, show_success_message=False)
            except Exception as e:
                messagebox.showerror("Ошибка сохранения", f"Не удалось сохранить файл: {e}")

    def revert_changes(self):
        if not self.editing_copy: return

        if not self.app_data.current_material:
            # Если это новый материал (оригинала нет), то просто сбрасываем редактор
            if messagebox.askyesno("Подтверждение", "Вы уверены, что хотите сбросить создание нового материала?"):
                self.create_new_material()
            return

        if messagebox.askyesno("Подтверждение", "Вы уверены, что хотите отменить все несохраненные изменения?"):
            self.load_material()

    def _populate_all_tabs(self):
        if not self.editing_copy: return
        self.general_tab.populate_form(self.editing_copy)
        self.phys_tab.populate_form(self.editing_copy)
        self.mech_tab.populate_form(self.editing_copy)
        self.chem_tab.populate_form(self.editing_copy)

    def collect_data(self):
        if not self.editing_copy: return
        self.general_tab.collect_data(self.editing_copy)
        self.phys_tab.collect_data(self.editing_copy)
        self.mech_tab.collect_data(self.editing_copy)
        self.chem_tab.collect_data(self.editing_copy)

    def _set_tabs_state(self, state):
        for i in range(self.notebook.index("end")):
            self.notebook.tab(i, state=state)


# ======================================================================================
# БЛОК 7: ГЛАВНЫЕ ФРЕЙМЫ И ЗАПУСК
# ======================================================================================


class ViewerFrame(ttk.Frame):
    """Контейнер для вкладки 'Подбор материала'."""

    def __init__(self, parent, app_data):
        super().__init__(parent)
        self.app_data = app_data
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill="both")

        # Вкладки создаются здесь, импортируемые из Блока 5
        self.temp_tab = TempSelectionTab(self.notebook, self.app_data)
        self.calc_tab = SingleCalculationTab(self.notebook, self.app_data)
        self.prop_tab = PropertyComparisonTab(self.notebook, self.app_data)
        self.chem_tab = ChemComparisonTab(self.notebook, self.app_data)
        self.ashby_tab = AshbyDiagramTab(self.notebook, self.app_data)

        self.notebook.add(self.temp_tab, text="Подбор по температуре")
        self.notebook.add(self.calc_tab, text="Расчет отдельно")
        self.notebook.add(self.prop_tab, text="Сравнение материалов (свойства)")
        self.notebook.add(self.chem_tab, text="Сравнение материалов (хим. состав)")
        self.notebook.add(self.ashby_tab, text="Диаграмма Эшби")

    def update_view(self):
        self.temp_tab.update_comboboxes()
        self.calc_tab.update_comboboxes()
        self.prop_tab.update_lists()
        self.chem_tab.update_lists()
        self.ashby_tab.update_lists()


class SourcesManagerTab(ttk.Frame):
    """
    Вкладка для управления источниками (CRUD).
    Позволяет создавать, редактировать и удалять источники в source.json.
    """

    def __init__(self, parent, app_data, main_app):
        super().__init__(parent)
        self.app_data = app_data
        self.main_app = main_app
        self.current_source_id = None  # ID редактируемого источника

        self._setup_widgets()

    def _setup_widgets(self):
        # --- 1. ТАБЛИЦА ИСТОЧНИКОВ ---
        list_frame = ttk.LabelFrame(self, text="Список источников", padding=5)
        list_frame.pack(fill="both", expand=True, padx=10, pady=5)

        columns = ("name", "desc", "link", "user_c", "date_c", "user_f", "date_f")
        self.tree = ttk.Treeview(list_frame, columns=columns, show="headings")

        self.tree.heading("name", text="Наименование")
        self.tree.column("name", width=250)
        self.tree.heading("desc", text="Описание")
        self.tree.column("desc", width=300)
        self.tree.heading("link", text="Ссылка/Файл")
        self.tree.column("link", width=150)

        # Служебные поля поуже
        self.tree.heading("user_c", text="Изм.")
        self.tree.column("user_c", width=80)
        self.tree.heading("date_c", text="Дата изм.")
        self.tree.column("date_c", width=120)
        self.tree.heading("user_f", text="Созд.")
        self.tree.column("user_f", width=80)
        self.tree.heading("date_f", text="Дата созд.")
        self.tree.column("date_f", width=120)

        vsb = ttk.Scrollbar(list_frame, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(list_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")

        list_frame.grid_rowconfigure(0, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)

        self.tree.bind("<<TreeviewSelect>>", self._on_select)
        # Двойной клик для открытия файла (если есть ссылка)
        self.tree.bind("<Double-1>", self._open_file_link)

        # --- 2. ПАНЕЛЬ РЕДАКТИРОВАНИЯ ---
        edit_frame = ttk.LabelFrame(self, text="Редактирование источника", padding=10)
        edit_frame.pack(fill="x", padx=10, pady=10, side="bottom")

        # Grid layout for editing fields
        ttk.Label(edit_frame, text="Наименование:").grid(row=0, column=0, sticky="w", pady=2)
        self.name_entry = ttk.Entry(edit_frame, width=80)
        self.name_entry.grid(row=0, column=1, sticky="w", pady=2)

        ttk.Label(edit_frame, text="Описание:").grid(row=1, column=0, sticky="w", pady=2)
        self.desc_entry = ttk.Entry(edit_frame, width=80)
        self.desc_entry.grid(row=1, column=1, sticky="w", pady=2)

        ttk.Label(edit_frame, text="Ссылка/Файл:").grid(row=2, column=0, sticky="w", pady=2)
        self.link_entry = ttk.Entry(edit_frame, width=80)
        self.link_entry.grid(row=2, column=1, sticky="w", pady=2)

        # Кнопки
        btn_frame = ttk.Frame(edit_frame)
        btn_frame.grid(row=3, column=0, columnspan=2, pady=10)

        self.btn_new = ttk.Button(btn_frame, text="Новый источник", command=self._create_new)
        self.btn_new.pack(side="left", padx=5)

        self.btn_save = ttk.Button(btn_frame, text="Сохранить изменения", command=self._save_changes, state="disabled")
        self.btn_save.pack(side="left", padx=5)

        self.btn_del = ttk.Button(btn_frame, text="Удалить источник", command=self._delete_source, state="disabled")
        self.btn_del.pack(side="left", padx=5)

        self.btn_clear = ttk.Button(btn_frame, text="Очистить поля", command=self._clear_form)
        self.btn_clear.pack(side="left", padx=5)

    def update_view(self):
        """Обновляет таблицу данными из SourceManager."""
        self._clear_form()
        self.tree.delete(*self.tree.get_children())

        if not self.app_data.source_manager:
            return

        sources = self.app_data.source_manager.get_all()
        # Сортируем по имени
        sources.sort(key=lambda s: s.get("name_source", "").lower())

        for src in sources:
            values = (
                src.get("name_source", ""),
                src.get("description", ""),
                src.get("hyperlink", ""),
                src.get("user_name_change", ""),
                src.get("data_change", ""),
                src.get("user_name_found", ""),
                src.get("data_found", "")
            )
            # Храним ID в hidden tags или просто во втором параметре insert (iid)
            self.tree.insert("", "end", iid=src["id_source"], values=values)

    def _on_select(self, event):
        selected = self.tree.selection()
        if not selected: return

        source_id = selected[0]
        self.current_source_id = source_id

        src = self.app_data.source_manager.get_source_by_id(source_id)
        if not src: return

        self.name_entry.delete(0, tk.END)
        self.name_entry.insert(0, src.get("name_source", ""))
        self.desc_entry.delete(0, tk.END)
        self.desc_entry.insert(0, src.get("description", ""))
        self.link_entry.delete(0, tk.END)
        self.link_entry.insert(0, src.get("hyperlink", ""))

        self.btn_save.config(state="normal")
        self.btn_del.config(state="normal")
        self.btn_new.config(state="disabled")  # Чтобы не создать дубль при редактировании

    def _clear_form(self):
        self.current_source_id = None
        self.name_entry.delete(0, tk.END)
        self.desc_entry.delete(0, tk.END)
        self.link_entry.delete(0, tk.END)
        self.tree.selection_remove(self.tree.selection())

        self.btn_save.config(state="disabled")
        self.btn_del.config(state="disabled")
        self.btn_new.config(state="normal")

    def _create_new(self):
        name = self.name_entry.get().strip()
        if not name:
            messagebox.showwarning("Внимание", "Введите наименование источника.")
            return

        desc = self.desc_entry.get().strip()
        link = self.link_entry.get().strip()

        self.app_data.source_manager.add_source(name, desc, link)
        self.update_view()
        messagebox.showinfo("Успех", "Источник создан.")

    def _save_changes(self):
        if not self.current_source_id: return

        name = self.name_entry.get().strip()
        if not name:
            messagebox.showwarning("Внимание", "Наименование не может быть пустым.")
            return

        desc = self.desc_entry.get().strip()
        link = self.link_entry.get().strip()

        success = self.app_data.source_manager.update_source(self.current_source_id, name, desc, link)
        if success:
            self.update_view()
            messagebox.showinfo("Успех", "Изменения сохранены.")
        else:
            messagebox.showerror("Ошибка", "Не удалось найти источник для обновления.")

    def _delete_source(self, event=None):
        if not self.current_source_id: return

        # 1. ПРОВЕРКА ИСПОЛЬЗОВАНИЯ В МАТЕРИАЛАХ
        # Нужно пробежаться по всем материалам и проверить, не используется ли этот ID
        usage_count = 0
        used_in = []

        for mat in self.app_data.materials:
            # Проверка физ
            if mat.data.get("physical_properties", {}).get("source_ref_id") == self.current_source_id:
                usage_count += 1
                used_in.append(mat.get_display_name())
                continue

            # Проверка мех (по категориям)
            cats = mat.data.get("mechanical_properties", {}).get("strength_category", [])
            for cat in cats:
                if cat.get("source_ref_id") == self.current_source_id:
                    usage_count += 1
                    used_in.append(mat.get_display_name())
                    break  # Одного совпадения в материале достаточно для блокировки

            # Проверка хим (по составам)
            comps = mat.data.get("chemical_properties", {}).get("composition", [])
            for comp in comps:
                if comp.get("source_ref_id") == self.current_source_id:
                    usage_count += 1
                    used_in.append(mat.get_display_name())
                    break

        if usage_count > 0:
            msg = f"Нельзя удалить источник!\nОн используется в {usage_count} материалах, например:\n" + "\n".join(
                used_in[:3])
            if len(used_in) > 3: msg += "\n..."
            messagebox.showerror("Ошибка удаления", msg)
            return

        if messagebox.askyesno("Подтверждение", "Вы уверены, что хотите удалить этот источник?"):
            self.app_data.source_manager.delete_source(self.current_source_id)
            self.update_view()

    def _open_file_link(self, event):
        """Открывает файл или ссылку из выделенного источника."""
        selected = self.tree.selection()
        if not selected: return
        src_id = selected[0]
        src = self.app_data.source_manager.get_source_by_id(src_id)

        link = src.get("hyperlink", "").strip()
        if not link: return

        # Если это локальный путь и он относительный, пробуем найти в папке Источники
        if not os.path.isabs(link) and not link.startswith("http"):
            # Проверяем в папке Источники
            sources_dir = os.path.join(get_app_directory(), "Источники")
            potential_path = os.path.join(sources_dir, link)
            if os.path.exists(potential_path):
                link = potential_path

        try:
            if sys.platform == "win32":
                os.startfile(link)
            elif sys.platform == "darwin":
                subprocess.call(["open", link])
            else:
                subprocess.call(["xdg-open", link])
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось открыть: {e}")


class MainApplication(tk.Tk):
    def __init__(self):
        super().__init__()
        self.app_data = AppData()
        self.title("Material_Lib (2.1.3)")
        self.geometry("1200x800")

        # Этот код для горячих клавиш можно оставить или убрать, если он не работает
        self.bind_class("Entry", "<KeyPress>", self._handle_russian_hotkeys)
        self.bind_class("Text", "<KeyPress>", self._handle_russian_hotkeys)
        self.bind_class("ttk::Combobox", "<KeyPress>", self._handle_russian_hotkeys)

        self.create_menu()
        self.create_widgets()

        # Автозагрузка
        try:
            default_dir = os.path.join(get_app_directory(), "БД Материалов")
            if os.path.isdir(default_dir):
                self.open_directory(directory=default_dir, show_success_message=False)
        except Exception as e:
            print(f"Ошибка автозагрузки: {e}")

    def _handle_russian_hotkeys(self, event):
        is_ctrl_pressed = (event.state & 4) != 0
        if is_ctrl_pressed:
            key = event.keysym.lower()
            if key == 'с':
                event.widget.event_generate("<<Copy>>")
                return "break"
            elif key == 'м':
                event.widget.event_generate("<<Paste>>")
                return "break"
            elif key == 'ч':
                event.widget.event_generate("<<Cut>>")
                return "break"
            elif key == 'ф':
                if isinstance(event.widget, tk.Text):
                    event.widget.tag_add("sel", "1.0", "end")
                elif isinstance(event.widget, tk.Entry):
                    event.widget.selection_range(0, 'end')
                return "break"

    def create_menu(self):
        self.menu_bar = tk.Menu(self)
        self.config(menu=self.menu_bar)

        file_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.menu_bar.add_cascade(label="Файл", menu=file_menu)
        file_menu.add_command(label="Открыть директорию...", command=self.open_directory)
        file_menu.add_separator()
        file_menu.add_command(label="Выход", command=self.quit)

        help_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.menu_bar.add_cascade(label="Справка", menu=help_menu)
        help_menu.add_command(label="Инструкция", command=self.show_instructions)
        help_menu.add_command(label="О приложении", command=self.show_about_info)
        help_menu.add_command(label="Список изменений", command=self.show_change)

    def create_widgets(self):
        self.main_notebook = ttk.Notebook(self)
        self.main_notebook.pack(expand=True, fill="both", padx=10, pady=10)

        self.viewer_frame = ViewerFrame(self.main_notebook, self.app_data)
        self.editor_frame = EditorFrame(self.main_notebook, self.app_data, self)
        self.sources_frame = SourcesManagerTab(self.main_notebook, self.app_data, self)

        self.main_notebook.add(self.viewer_frame, text="Подбор материала")
        self.main_notebook.add(self.editor_frame, text="Добавление / Редактирование материала")
        self.main_notebook.add(self.sources_frame, text="Работа с источниками")

    def open_directory(self, directory=None, show_success_message=True):
        if not directory:
            filepath = filedialog.askopenfilename(title="Выберите любой .json", filetypes=[("JSON files", "*.json")])
            if filepath:
                directory = os.path.dirname(filepath)
            else:
                return

        if directory:
            try:
                self.app_data.load_materials_from_dir(directory)
                if show_success_message: messagebox.showinfo("Успех",
                                                             f"Загружено {len(self.app_data.materials)} материалов.")
                self.on_data_load()
            except Exception as e:
                messagebox.showerror("Ошибка", f"Сбой загрузки: {e}")

    def on_data_load(self):
        self.editor_frame.editing_copy = None
        self.app_data.current_material = None
        self.viewer_frame.update_view()
        self.editor_frame.update_view()
        self.sources_frame.update_view()


    def show_about_info(self):
        title = "О приложении"
        message = read_text_from_file("app_list.txt")
        messagebox.showinfo(title, message, parent=self)

    def show_instructions(self):
        instr_window = tk.Toplevel(self)
        instr_window.title("Инструкция по использованию")
        instr_window.geometry("750x600")
        instr_window.minsize(500, 400)
        instruction_text = read_text_from_file("instruction_list.txt")
        text_frame = ttk.Frame(instr_window, padding=10)
        text_frame.pack(fill="both", expand=True)
        text_widget = tk.Text(text_frame, wrap=tk.WORD, state="disabled", font=("Arial", 10), padx=5, pady=5)
        scrollbar = ttk.Scrollbar(text_frame, orient="vertical", command=text_widget.yview)
        text_widget.config(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        text_widget.pack(side="left", fill="both", expand=True)
        text_widget.config(state="normal")
        text_widget.insert("1.0", instruction_text.strip())
        text_widget.config(state="disabled")
        ok_button = ttk.Button(instr_window, text="OK", command=instr_window.destroy)
        ok_button.pack(pady=(0, 10))

    def show_change(self):
        instr_window = tk.Toplevel(self)
        instr_window.title("Список изменений")
        instr_window.geometry("750x600")
        instr_window.minsize(500, 400)
        instruction_text = read_text_from_file("change_list.txt")
        text_frame = ttk.Frame(instr_window, padding=10)
        text_frame.pack(fill="both", expand=True)
        text_widget = tk.Text(text_frame, wrap=tk.WORD, state="disabled", font=("Arial", 10), padx=5, pady=5)
        scrollbar = ttk.Scrollbar(text_frame, orient="vertical", command=text_widget.yview)
        text_widget.config(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        text_widget.pack(side="left", fill="both", expand=True)
        text_widget.config(state="normal")
        text_widget.insert("1.0", instruction_text.strip())
        text_widget.config(state="disabled")
        ok_button = ttk.Button(instr_window, text="OK", command=instr_window.destroy)
        ok_button.pack(pady=(0, 10));


if __name__ == "__main__":
    app = MainApplication()
    app.mainloop()